# Copyright 2000-2010,2014-2016 BitMover, Inc

# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at

#     http://www.apache.org/licenses/LICENSE-2.0

# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

DASHA=
test X`uname -s` = XDarwin && DASHA=-a

echo $N Test locks behave the same in pull -R and just pull..........$NL
cd "$HERE"
commercial locking_parent
cd "$HERE"
bk clone $Q locking_parent locking_child
cd locking_child
mkdir -p BitKeeper/triggers
cat > BitKeeper/triggers/post-incoming <<EOF
#!/bin/bash
echo Running lock command
bk lock -l > "$HERE/trigger-lock-result" 2>&1
EOF
chmod +x BitKeeper/triggers/post-incoming
cd "$HERE/locking_parent"
touch afile
bk new $Q afile
bk commit -y. $Q
cd "$HERE/locking_child"
bk pull $Q || fail
grep -q "Entire repository is locked" "$HERE/trigger-lock-result" || \
	fail -f "$HERE/trigger-lock-result"
rm -f "$HERE/trigger-lock-result"
bk unpull -f $Q || fail
bk pull $Q -R || fail
test -f "$HERE/trigger-lock-result" && fail
bk resolve $Q || fail
grep -q "Entire repository is locked" "$HERE/trigger-lock-result" || \
	fail -f "$HERE/trigger-lock-result"
rm -f "$HERE/trigger-lock-result"
echo OK

echo $N Check commit trigger environment variables ..................$NL
cd "$HERE"
commercial project
bk edit $Q BitKeeper/etc/config
echo "checkout: get" >> BitKeeper/etc/config
bk delta $Q -ycheckout BitKeeper/etc/config
bk commit $Q -ycheckout
mkdir BitKeeper/triggers
cat > BitKeeper/triggers/pre-commit <<EOF
#!/bin/bash
set | grep $DASHA ^BK | grep -v _BK_ | bk sort > "$HERE/pre-commit"
exit 0
EOF
cat > BitKeeper/triggers/post-commit <<EOF
#!/bin/bash
set | grep $DASHA ^BK | grep -v _BK_ | bk sort > "$HERE/post-commit"
exit 0
EOF
chmod +x BitKeeper/triggers/*
echo h > h.h
bk ci $Q -i h.h
bk commit $S -yCset
grep -q BK_CSETS "$HERE/pre-commit" && {
	echo should not have defined BK_CSETS in pre-commit
	exit 1
}
grep -q BK_STATUS=OK "$HERE/post-commit" || {
	echo no/bad exit status
	cat "$HERE/post-commit"
	exit 1
}
grep -q BK_REPO_TYPE=standalone "$HERE/post-commit" || {
	echo no repo type
	cat "$HERE/post-commit"
	exit 1
}
grep -q "pre-commit returns 0" BitKeeper/log/cmd_log || {
	echo should have logged trigger
	exit 1
}
grep -q "post-commit returns 0" BitKeeper/log/cmd_log || {
	echo should have logged trigger
	exit 1
}
echo OK
test -z "$DUMP_VARS" || {
	echo ========== pre-commit ==========
	cat "$HERE/pre-commit"
	echo ========== post-commit ==========
	cat "$HERE/post-commit"
}

echo $N Test trigger path support by running repo triggers 3x .......$NL
cd "$HERE"
bk clone $Q project test_path
cd test_path
mkdir BitKeeper/triggers
cat > BitKeeper/triggers/pre-commit <<EOF
#!/bin/bash
echo \$BK_TRIGGERPATH >> "$HERE/paths"
exit 0
EOF
chmod +x BitKeeper/triggers/*
echo whatever > whatever
bk new $Q whatever
BK_CONFIG='triggers: .|.|.' bk commit $Q -ywhatever
test -f "$HERE/paths" || {
	echo did not run the triggers
	exit 1
}
grep -q "./BitKeeper/triggers/pre-commit" "$HERE/paths" || {
	echo bad paths
	cat "$HERE/paths"
	exit 1
}
test `wc -l < "$HERE/paths"` -eq 3 || {
	echo did not run all trigger paths
	cat "$HERE/paths"
	exit 1
}
echo OK

echo $N make sure that triggers:none works ..........................$NL
echo whatever > whatever2
bk new $Q whatever2
rm -f "$HERE/paths"
BK_CONFIG='triggers: none' bk commit $Q -ywhatever
test -f "$HERE/paths" && {
	echo should not have run the triggers
	exit 1
}
echo OK

echo $N Test trigger path support with path outside of repo .........$NL
mkdir -p "$HERE/trigger_dir/BitKeeper/triggers"
cp BitKeeper/triggers/pre-commit "$HERE/trigger_dir/BitKeeper/triggers/"
chmod +x "$HERE/trigger_dir/BitKeeper/triggers/pre-commit"
echo whatever > whatever3
bk new $Q whatever3
rm -f "$HERE/paths"
BK_CONFIG="triggers: $HERE/trigger_dir" bk commit $Q -ywhatever
test -f "$HERE/paths" || {
	echo did not run the triggers
	exit 1
}
cat > WANT <<EOF
$HERE/trigger_dir/BitKeeper/triggers/pre-commit
EOF
cmpfiles WANT "$HERE/paths"
echo OK

echo $N Test trigger path support with path inside+outside repo .....$NL
echo whatever > whatever4
bk new $Q whatever4
rm -f "$HERE/paths"
BK_CONFIG="triggers: .|$HERE/trigger_dir" bk commit $Q -ywhatever
test -f "$HERE/paths" || {
	echo did not run the triggers
	exit 1
}
cat > WANT <<EOF
$HERE/test_path/BitKeeper/triggers/pre-commit
$HERE/trigger_dir/BitKeeper/triggers/pre-commit
EOF
cmpfiles WANT "$HERE/paths"
echo OK

echo $N Test trigger path support with path inside+BK_DOTBK .........$NL
mv "$HERE/trigger_dir/BitKeeper" "$BK_DOTBK"
rmdir "$HERE/trigger_dir"
echo whatever > whatever5
bk new $Q whatever5
rm -f "$HERE/paths"
BK_CONFIG='triggers: .|$BK_DOTBK' bk commit $Q -ywhatever
test -f "$HERE/paths" || {
	echo did not run the triggers
	exit 1
}
cat > WANT <<EOF
$HERE/test_path/BitKeeper/triggers/pre-commit
$BK_DOTBK/BitKeeper/triggers/pre-commit
EOF
cmpfiles WANT "$HERE/paths"
echo OK

echo $N Make sure commit can be told to fail and it does so nicely ..$NL
cd "$HERE/project"
cat > BitKeeper/triggers/pre-commit <<EOF
#!/bin/bash
exit 1
EOF
chmod +x BitKeeper/triggers/*
echo c > c.c
bk ci $Q -i c.c
bk commit -yCset2 2>ERR && {
	echo failed to exit with an error status
	exit 1
}
if [ `bk sfiles -gp` != c.c ]
then	echo bad pending list
	exit 1
fi
echo '>> Trigger "pre-commit" (exit status was 1)' > WANT
cmpfiles ERR WANT
echo OK

cd "$HERE"
tar cf TAR project
cd project

echo $N Test noisy pre-trigger in commit ............................$NL
rm -f BitKeeper/triggers/*
cat > BitKeeper/triggers/pre-commit-noisy <<EOF
#!/bin/sh
echo Hi there, I am a trigger.
echo Hi there to stderr 1>&2
exit 0
EOF
chmod +x BitKeeper/triggers/pre-commit-noisy
echo whatever > somefile
bk new $Q somefile
bk commit -ywhatever > OUT 2>&1 || {
	echo commit failed unexpectedly
	cat OUT
	exit 1
}
grep -q 'Hi there, I am a trigger.' OUT && grep -q 'Hi there to stderr' OUT || {
	echo wrong trigger outout
	cat OUT
	exit 1
}
echo OK

echo $N Make sure that we can silence pre-triggers in commit ........$NL
bk edit $Q somefile
echo whatever >> somefile
bk delta -ywhatever $Q somefile
bk commit -q -ywhatever > OUT 2>&1 || {
	echo commit failed unexpectedly
	cat OUT
	exit 1
}
test -s OUT && {
	echo commit should have been silent and was not
	cat OUT
	exit 1
}
echo OK

echo $N Test noisy post-trigger in commit ...........................$NL
rm -f BitKeeper/triggers/*
cat > BitKeeper/triggers/post-commit-noisy <<EOF
#!/bin/sh
echo Hi there, I am a trigger.
echo Hi there to stderr 1>&2
exit 0
EOF
chmod +x BitKeeper/triggers/post-commit-noisy
bk edit $Q somefile
echo whatever >> somefile
bk delta $Q -ywhatever somefile
bk commit -ywhatever > OUT 2>&1 || {
	echo commit failed unexpectedly
	cat OUT
	exit 1
}
grep -q 'Hi there, I am a trigger.' OUT && grep -q 'Hi there to stderr' OUT || {
	echo wrong trigger outout
	cat OUT
	exit 1
}
echo OK

echo $N Make sure that we can silence post-triggers in commit .......$NL
bk edit $Q somefile
echo whatever >> somefile
bk delta -ywhatever $Q somefile
bk commit -q -ywhatever > OUT 2>&1 || {
	echo commit failed unexpectedly
	cat OUT
	exit 1
}
test -s OUT && {
	echo commit should have been silent and was not
	cat OUT
	exit 1
}
echo OK

echo $N Test noisy post-trigger in pull .............................$NL
bk clone -q -r1.4 "$HERE/project" "$HERE/noise"
cd "$HERE/noise"
mkdir BitKeeper/triggers
cat > BitKeeper/triggers/post-incoming-noisy <<EOF
#!/bin/sh
echo Hi there, I am a trigger.
echo Hi there to stderr 1>&2
exit 0
EOF
chmod +x BitKeeper/triggers/post-incoming-noisy
bk pull > OUT 2>ERR || {
	echo pull failed unexpectedly
	cat OUT ERR
	exit 1
}
grep -q 'Hi there, I am a trigger.' ERR && grep -q 'Hi there to stderr' ERR || {
	echo wrong trigger outout
	echo == stdout ==
	cat OUT
	echo == stderr ==
	cat ERR
	exit 1
}
echo OK

echo $N Make sure that we can silence post-triggers in pull .........$NL
bk unpull -fsq
bk pull -q > OUT 2>&1 || {
	echo pull failed unexpectedly
	cat OUT
	exit 1
}
test -s OUT && {
	echo pull should have been silent and was not
	cat OUT
	exit 1
}
echo OK

echo $N Test noisy pre-trigger in pull ..............................$NL
rm -f BitKeeper/triggers/*
cd "$HERE/project"
cat > BitKeeper/triggers/pre-outgoing-noisy <<EOF
#!/bin/sh
echo This is the pre-outgoing-noisy trigger
echo Hi there to stderr 1>&2
exit 0
EOF
chmod +x BitKeeper/triggers/pre-outgoing-noisy
cd "$HERE/noise"
bk unpull -fsq
bk pull -v > OUT 2>ERR || {
	echo pull failed unexpectedly
	cat OUT
	exit 1
}
grep -q 'This is the pre-outgoing-noisy trigger' ERR &&
grep -q 'Hi there to stderr' ERR || {
	echo wrong trigger outout
	cat OUT
	exit 1
}
echo OK

echo $N Make sure that we can silence pre-triggers in pull ..........$NL
bk unpull -fsq
bk pull -q > OUT 2>&1 || {
	echo pull failed unexpectedly
	cat OUT
	exit 1
}
test -s OUT && {
	echo pull should have been silent and was not
	cat OUT
	exit 1
}
echo OK

echo $N Test noisy pre-trigger in pull via bkd ......................$NL
cd "$HERE/project"
bk bkd -d -aPORT -l"$HERE/BKD.log" -P"$HERE/BKD.pid" -ikill
PORT=`cat PORT`
cd "$HERE/noise"
bk unpull -fsq
bk pull bk://localhost:$PORT > OUT 2>ERR || {
	echo pull failed unexpectedly
	cat OUT
	exit 1
}
grep -q 'This is the pre-outgoing-noisy trigger' ERR &&
grep -q 'Hi there to stderr' ERR || {
	echo wrong trigger outout
	cat OUT
	exit 1
}
echo OK

echo $N Make sure that we can silence pre-triggers in pull via bkd ..$NL
bk unpull -fsq
bk pull -q bk://localhost:$PORT > OUT 2>&1 || {
	echo pull failed unexpectedly
	cat OUT
	exit 1
}
test -s OUT && {
	echo pull should have been silent and was not
	cat OUT
	exit 1
}
echo OK

echo $N Test noisy post-trigger in pull via bkd .....................$NL
cd "$HERE/project"
cat > BitKeeper/triggers/post-outgoing-noisy <<EOF
#!/bin/sh
echo This is the post-outgoing-noisy trigger
echo Hi there from post-outgoing-noisy to stderr 1>&2
exit 0
EOF
chmod +x BitKeeper/triggers/post-outgoing-noisy
cd "$HERE/noise"
bk unpull -fsq
bk pull bk://localhost:$PORT > OUT 2>ERR || {
	echo pull failed unexpectedly
	cat OUT
	exit 1
}
grep -q 'This is the pre-outgoing-noisy trigger' ERR &&
grep -q 'Hi there to stderr' ERR || {
	echo wrong trigger outout
	cat OUT
	exit 1
}
bk lock -U "$HERE/project"
bk _kill bk://localhost:$PORT || fail
grep -q '>> Trigger "post-outgoing-noisy"' "$HERE/BKD.log" &&
grep -q 'This is the post-outgoing-noisy trigger' "$HERE/BKD.log" &&
grep -q 'Hi there from post-outgoing-noisy to stderr' "$HERE/BKD.log" || {
	echo failed to log post trigger to bkd logfile
	exit 1
}
echo OK

echo $N Check tag trigger environment variables without rev .........$NL
cd "$HERE"
rm -rf project
tar xf TAR
cd project
cat > BitKeeper/triggers/pre-tag <<EOF
#!/bin/bash
set | grep $DASHA ^BK | grep -v _BK_ | bk sort > "$HERE/pre-tag"
exit 0
EOF
chmod +x BitKeeper/triggers/pre-tag
bk tag $Q check_vars
grep -q BK_TAG=check_vars "$HERE/pre-tag" || {
	echo No BK_TAG in environment or wrong value
	exit 1
}
grep -q BK_TAG_REV "$HERE/pre-tag" && {
	echo Should not have set BK_TAG_REV
	exit 1
}
echo OK
test -z "$DUMP_VARS" || {
	echo ========== pre-tag ==========
	cat "$HERE/pre-tag"
}

echo $N Check tag trigger environment variables with rev ............$NL
bk tag $Q -r1.1 primordial_ooze
grep -q BK_TAG=primordial_ooze "$HERE/pre-tag" || {
	echo No BK_TAG in environment or wrong value
	exit 1
}
grep -q BK_TAG_REV=1.1 "$HERE/pre-tag" || {
	echo Should have set BK_TAG_REV=1.1
	exit 1
}
echo OK
test -z "$DUMP_VARS" || {
	echo ========== pre-tag ==========
	cat "$HERE/pre-tag"
}

echo $N Make sure tag can be told to fail and it does so nicely .....$NL
cat > BitKeeper/triggers/pre-tag <<EOF
#!/bin/bash
exit 1
EOF
chmod +x BitKeeper/triggers/*
bk tag foo 2>ERR && {
	echo failed to exit with an error status
	exit 1
}
echo '>> Trigger "pre-tag" (exit status was 1)' > WANT
cmpfiles ERR WANT
echo OK
cd "$HERE"
rm -rf project
tar xf TAR
cd project

echo $N Make sure we get the list of pending files in pre-commit ....$NL
cat > BitKeeper/triggers/pre-commit <<EOF
#!/bin/bash 
cp "\$BK_PENDING" "$HERE/BK_PENDING"
exit 1
EOF
chmod +x BitKeeper/triggers/*
bk commit $S -yCset2 2>/dev/null && {
	echo failed to exit with an error status
	exit 1
}
test -f "$HERE/BK_PENDING" || {
	echo failed to copy the file
	exit 1
}
test c.c${BK_FS}1.1 = `cat "$HERE/BK_PENDING"` || {
	echo bad file list
	cat "$HERE/BK_PENDING"
	exit 1
}
echo OK

echo $N Extract user from file list of pending deltas ...............$NL
test `bk prs -hd':USER:\n' - < "$HERE/BK_PENDING"` = bk || {
	echo can not extract user from file list
	exit 1
}
echo OK

echo $N Make sure commit succeeds when told it is OK ................$NL
cat > BitKeeper/triggers/pre-commit <<EOF
#!/bin/bash
exit 0
EOF
chmod +x BitKeeper/triggers/*
bk commit $S -yCset2 || {
	echo failed
	exit 1
}
echo OK

echo $N Make sure clone is passed the right variables ...............$NL
cat > BitKeeper/triggers/pre-outgoing <<EOF
#!/bin/bash
set | grep $DASHA ^BK | grep -v _BK_ |
 	bk sort > "$HERE/pre-outgoing"
exit 1
EOF
cat > BitKeeper/triggers/post-outgoing <<EOF
#!/bin/bash
set | grep $DASHA ^BK | grep -v _BK_ |
	bk sort > "$HERE/post-outgoing"
EOF
chmod +x BitKeeper/triggers/*
project_repoid=`bk identity -r`
cd "$HERE"
bk clone -q project clone 2>/dev/null && {
	echo failed to exit with an error status
	exit 1
}
test -d clone && {
	echo should not have created repository
	exit 1
}
bk clone -q -r1.1 project clone 2>/dev/null
grep -q BK_CSETS=..1.1 "$HERE/pre-outgoing" || {
	echo failed to put cset list in the env
	exit 1
}
rm project/BitKeeper/triggers/pre-outgoing
bk clone $Q -r1.1 project clone || {
	echo should have succeeded and did not
	exit 1
}
bk clone -q -r1.1 project apply || {
	echo should have succeeded and did not
	exit 1
}
test -d clone || {
	echo should have created repository
	exit 1
}
grep -q BK_CSETS=..1.1 "$HERE/post-outgoing" || {
	echo failed to put cset list in the env
	exit 1
}
grep BKD_REPO_ID= "$HERE/post-outgoing" > "$HERE/tmp"
fgrep "$project_repoid" "$HERE/tmp" > /dev/null || {
	echo "failed to record where we came from which is $project_repoid"
	cat "$HERE/post-outgoing"
	exit 1
}
echo OK
test -z "$DUMP_VARS" || {
	echo ========== pre-outgoing clone ==========
	cat "$HERE/pre-outgoing"
	echo ========== post-outgoing clone ==========
	cat "$HERE/post-outgoing"
}

echo $N Make sure clone -l is passed the right variables ............$NL
cd "$HERE/project"
cat > BitKeeper/triggers/pre-outgoing <<EOF
#!/bin/bash
set | grep $DASHA ^BK | grep -v _BK_ |
	bk sort > "$HERE/pre-outgoing-l"
exit 1
EOF
cat > BitKeeper/triggers/post-outgoing <<EOF
#!/bin/bash
set | grep $DASHA ^BK | grep -v _BK_ |
	bk sort > "$HERE/post-outgoing-l"
EOF
chmod +x BitKeeper/triggers/*
cd "$HERE"
bk clone -l -q project lclone 2>GOT && {
	echo failed to exit with an error status
	exit 1
}
test -d lclone && {
	echo should not have created repository
	exit 1
}
cat <<EOF > WANT
------------------------- Remote trigger message --------------------------
>> Trigger "pre-outgoing" (exit status was 1)
---------------------------------------------------------------------------
EOF
cmpfiles WANT GOT
bk clone -q -l -r1.1 project lclone 2> GOT
cmpfiles WANT GOT
grep -q BK_CSETS=..1.1 "$HERE/pre-outgoing" || {
	echo failed to put cset list in the env
	exit 1
}
rm project/BitKeeper/triggers/pre-outgoing
bk clone -q -l -r1.1 project lclone || {
	echo should have succeeded and did not
	exit 1
}
test -d lclone || {
	echo should have created repository
	exit 1
}
grep -q BK_CSETS=..1.1 "$HERE/post-outgoing" || {
	echo failed to put cset list in the env
	exit 1
}
echo OK
test -z "$DUMP_VARS" || {
	echo ========== pre-outgoing clone -l ==========
	cat "$HERE/pre-outgoing-l"
	echo ========== post-outgoing clone -l ==========
	cat "$HERE/post-outgoing-l"
}

echo $N Make sure clone and clone -l have same pre-outgoing .........$NL
cmp -s "$HERE/pre-outgoing" "$HERE/pre-outgoing-l" || {
	echo failed
	diff -u "$HERE/pre-outgoing" "$HERE/pre-outgoing-l"
	exit 1
}
echo OK

echo $N Make sure clone and clone -l have same post-outgoing ........$NL
cmp -s "$HERE/post-outgoing" "$HERE/post-outgoing-l" || {
	echo failed
	diff "$HERE/post-outgoing" "$HERE/post-outgoing-l"
	exit 1
}
echo OK

# Make a post-incoming trigger be checked in, see if clone runs it.
echo $N Test post-incoming in a clone ...............................$NL
cd "$HERE"
cp -rp project parent
cd parent
rm -f BitKeeper/triggers/*
cat > BitKeeper/triggers/post-incoming <<EOF
#!/bin/bash
# ignore BK_REPO_ID because clone and clone-l had different ids
set | grep $DASHA ^BK | grep -v _BK_ |
    grep -v BK_REPO_ID= |
    grep -v BKD_TIP |
    bk sort > "$HERE/post-incoming-clone"
exit 0
EOF
chmod +x BitKeeper/triggers/post-incoming
bk new $Q BitKeeper/triggers/post-incoming
bk commit $Q -ypost-incoming
# kill time based race in repo_nfiles() by recomputing NFILES
bk -r check -a
cd "$HERE"
bk clone $Q parent clone2
test -f "$HERE/post-incoming-clone" || {
	echo failed to run post-incoming trigger
	exit 1
}
grep BKD_REPO_ID= "$HERE/post-incoming-clone" > "$HERE/tmp"
fgrep "$project_repoid" "$HERE/tmp" > /dev/null || {
	echo "failed to record where we came from which is $project_repoid"
	cat "$HERE/post-incoming-clone"
	exit 1
}
echo OK
test -z "$DUMP_VARS" || {
	echo ========== post-incoming clone ==========
	cat "$HERE/post-incoming-clone"
}

# Make a post-incoming trigger be checked in, see if clone -l runs it.
echo $N Test post-incoming in a clone -l ............................$NL
cd "$HERE/parent"
bk edit $Q BitKeeper/triggers
cat > BitKeeper/triggers/post-incoming <<EOF
#!/bin/bash
set | grep $DASHA ^BK |
    grep -v _BK_ |
    grep -v BK_REPO_ID= |
    grep -v BKD_TIP |
    bk sort > "$HERE/post-incoming-clone-l"
exit 0
EOF
bk delta -y-l $Q BitKeeper/triggers/post-incoming
bk commit $Q -ypost-incoming-l
# kill time based race in repo_nfiles() by recomputing NFILES
bk -r check -a
cd "$HERE"
rm -rf clone2
bk clone -l $Q parent clone2
test -f "$HERE/post-incoming-clone-l" || {
	echo failed to run post-incoming trigger
	exit 1
}
echo OK
test -z "$DUMP_VARS" || {
	echo ========== post-incoming clone -l ==========
	cat "$HERE/post-incoming-clone-l"
}

echo $N Make sure clone and clone -l have same post-incoming ........$NL
cmp -s "$HERE/post-incoming-clone" "$HERE/post-incoming-clone-l" || {
	echo failed
	diff -u "$HERE/post-incoming-clone" "$HERE/post-incoming-clone-l"
	exit 1
}
echo OK

cd "$HERE"
rm -rf parent clone2

echo $N Make sure pull is passed the right variables ................$NL
cd "$HERE/project"
cat > BitKeeper/triggers/pre-outgoing <<EOF
#!/bin/bash
set | grep $DASHA ^BK | grep -v _BK_ | bk sort > "$HERE/pre-outgoing"
cp \$BK_CSETLIST "$HERE/CSETS"
exit 1
EOF
chmod +x BitKeeper/triggers/*
cd "$HERE/clone"
bk pull $Q 2>/dev/null && {
	echo failed to exit with an error status
	exit 1
}
grep -q BK_CSETLIST "$HERE/pre-outgoing" || {
	echo failed to put cset list file in the env
	cat "$HERE/pre-outgoing"
	exit 1
}
grep -q BK_LOCALCSETS=2 "$HERE/pre-outgoing" || 
grep -q BK_LOCALCSETS=3 "$HERE/pre-outgoing" || {
	echo failed to put local csets in the env
	cat "$HERE/pre-outgoing"
	exit 1
}
grep -q BK_REMOTECSETS=0 "$HERE/pre-outgoing" || {
	echo failed to put remote csets in the env
	cat "$HERE/pre-outgoing"
	exit 1
}
test -d RESYNC && {
	echo failed to clean up RESYNC dir
	exit 1
}
echo OK

echo $N Make sure pre-incoming triggers fail the pull ...............$NL
rm "$HERE/project/BitKeeper/triggers/pre-outgoing"
cd "$HERE/clone"
mkdir BitKeeper/triggers
cat > BitKeeper/triggers/pre-incoming <<EOF
#!/bin/bash
set | grep $DASHA ^BK | grep -v _BK_ | bk sort > "$HERE/pre-incoming"
exit 1
EOF
chmod +x BitKeeper/triggers/*
bk pull $Q 2>ERR && {
	echo failed to exit non zero with failed pre-incoming trigger
	exit 1
}
test -d RESYNC && {
	echo failed to clean up RESYNC
	exit 1
}
echo '>> Trigger "pre-incoming" (exit status was 1)' > WANT
cmpfiles ERR WANT
echo OK
test -z "$DUMP_VARS" || {
	echo ========== pre-incoming ==========
	cat "$HERE/pre-incoming"
}

echo $N Make sure pre-resolve triggers fail the pull ................$NL
cd "$HERE/clone"
rm BitKeeper/triggers/*
cat > BitKeeper/triggers/pre-resolve <<EOF
#!/bin/bash
set | grep $DASHA ^BK | grep -v _BK_ | bk sort > "$HERE/pre-resolve"
pwd > "$HERE/PWD"
exit 1
EOF
chmod +x BitKeeper/triggers/*
bk pull -q 2>ERR && {
	echo failed to exit non zero with failed pre-resolve trigger
	exit 1
}
test -d RESYNC && {
	echo failed to clean up RESYNC
	exit 1
}
test -f "$HERE/pre-resolve" || {
	echo failed to call trigger
	exit 1
}
grep -q "pre-resolve returns 1" BitKeeper/log/cmd_log || {
	echo should have logged trigger
	exit 1
}
echo '>> Trigger "pre-resolve" (exit status was 1)' > WANT
cmpfiles ERR WANT
echo OK
test -z "$DUMP_VARS" || {
	echo ========== pre-resolve ==========
	cat "$HERE/pre-resolve"
}

echo $N Make sure we can see the data in the pre-resolve trigger ....$NL
cat > BitKeeper/triggers/pre-resolve <<EOF
#!/bin/bash
bk changes - < \$BK_CSETLIST > "$HERE/changes"
cp \$BK_CSETLIST "$HERE/csets-out"
pwd > "$HERE/resolve-pwd"
exit 1
EOF
chmod +x BitKeeper/triggers/*
bk pull -q 2>ERR && {
	echo failed to exit non zero with failed pre-incoming trigger
	exit 1
}
test -d RESYNC && {
	echo failed to clean up RESYNC
	exit 1
}
test -s "$HERE/changes" || {
	echo failed to create change list
	exit 1
}
grep -q ChangeSet@1.3 "$HERE/changes" || {
	echo failed to list the ChangeSet
	exit 1
}
GOT=`wc -l < "$HERE/csets-out"`
if [ $GOT -ne 2 -a $GOT -ne 3 ]; then
	echo csets-out contains extra junk
	cat "$HERE/csets-out"
	exit 1
fi
GOT=`grep '^ChangeSet' "$HERE/changes" | wc -l`
if [ $GOT -ne 2 -a $GOT -ne 3 ]; then
	echo listed extra changes
	exit 1
fi
echo '>> Trigger "pre-resolve" (exit status was 1)' > WANT
cmpfiles ERR WANT
echo OK

echo $N Make sure the pre-resolve trigger is run in RESYNC ..........$NL
grep -q RESYNC "$HERE/resolve-pwd" || {
	echo failed
	cat RESYNC "$HERE/resolve-pwd"
	exit 1
}
echo OK

echo $N Check bk changes -v - .......................................$NL
echo 1.1 > list
echo junk >> list
bk changes - < list > /dev/null 2>&1 && {
	echo failed to reject junk
	exit 1
}
echo 1.1 > list
echo \#junk >> list
echo >> list
bk changes - < list > out || {
	echo didn\'t ignore blanks and comments
	exit 1
}
if [ `grep '^ChangeSet' out | wc -l` -ne 1 ]; then
	echo returned extra junk
	exit 1
fi
echo OK

echo $N Make sure pre-apply exiting 1 cleans up .....................$NL
cd "$HERE/apply"
test -d BitKeeper/triggers || mkdir BitKeeper/triggers
cat > BitKeeper/triggers/pre-apply <<EOF
#!/bin/bash
set | grep $DASHA ^BK | grep -v _BK_ | bk sort -u > "$HERE/pre-apply"
pwd > "$HERE/apply-pwd"
exit 1
EOF
chmod +x BitKeeper/triggers/*
bk pull -q 2>ERR && {
	echo failed to exit non zero with failed pre-apply trigger
	exit 1
}
test -d RESYNC && {
	echo failed to clean up RESYNC
	exit 1
}
test -d PENDING && {
	echo failed to clean up PENDING
	exit 1
}
echo '>> Trigger "pre-apply" (exit status was 1)' > WANT
cmpfiles ERR WANT
echo OK
test -z "$DUMP_VARS" || {
	echo ========== pre-apply ==========
	cat "$HERE/pre-apply"
}

echo $N Make sure the pre-apply trigger is run in RESYNC ............$NL
grep -q RESYNC "$HERE/apply-pwd" || {
	echo failed
	cat RESYNC "$HERE/apply-pwd"
	exit 1
}
echo OK

echo $N Make sure pre-apply exiting 2 leaves patch in PENDING .......$NL
cd "$HERE/apply"
test -d BitKeeper/triggers || mkdir BitKeeper/triggers
cat > BitKeeper/triggers/pre-apply <<EOF
#!/bin/bash
exit 2
EOF
chmod +x BitKeeper/triggers/*
bk pull -q 2>ERR && {
	echo failed to exit non zero with failed pre-apply trigger
	exit 1
}
test -d RESYNC && {
	echo failed to clean up RESYNC
	exit 1
}
test -d PENDING || {
	echo failed to leave PENDING
	exit 1
}
echo '>> Trigger "pre-apply" (exit status was 2)' > WANT
cmpfiles ERR WANT
echo OK

echo $N Make sure pre-apply exiting 3 leaves RESYNC and PENDING .....$NL
cd "$HERE/apply"
test -d BitKeeper/triggers || mkdir BitKeeper/triggers
cat > BitKeeper/triggers/pre-apply <<EOF
#!/bin/bash
exit 3
EOF
chmod +x BitKeeper/triggers/*
bk pull -q 2>ERR && {
	echo failed to exit non zero with failed pre-apply trigger
	exit 1
}
X=`ls -d RESYNC-* | wc -l`
test "$X" -eq 1 || {
	echo failed to leave RESYNC
	exit 1
}
test -d PENDING || {
	echo failed to leave PENDING
	exit 1
}
echo '>> Trigger "pre-apply" (exit status was 3)' > WANT
cmpfiles ERR WANT
test -d RESYNC-*/.bk || {
	echo failed to create blobified RESYNC
	exit 1
}
echo OK

echo $N Do it again to see that it can rename RESYNC twice ..........$NL
bk pull -q 2>ERR && {
	echo failed to exit non zero with failed pre-apply trigger
	exit 1
}
test -d "RESYNC" && {
	echo failed to rename RESYNC
	exit 1
}
X=`ls -d RESYNC-* | wc -l`
test "$X" -eq 2 || {
	echo failed to leave RESYNC
	exit 1
}
test -d PENDING || {
	echo failed to leave PENDING
	exit 1
}
echo '>> Trigger "pre-apply" (exit status was 3)' > WANT
cmpfiles ERR WANT
echo OK

echo $N Make sure that pushes do not prompt in pre-apply ............$NL
cd "$HERE/apply"
test -d BitKeeper/triggers || mkdir BitKeeper/triggers
# This is quoted so that I don't have to escape all the $VAR instances
# in the shell script.  Sigh.
bk base64 -d > BitKeeper/triggers/pre-apply <<EOF 
IyEvYmluL3NoCgp0ZXN0IGBiayBnZmlsZXMgQml0S2VlcGVyL3RyaWdnZXJzIHwg
d2MgLWxgIC1ndCAwIHx8IGV4aXQgMAppZiBbICRCS19TSURFID0gc2VydmVyIF0K
dGhlbiAgICBlY2hvIFJlZnVzaW5nIHRvIGFjY2VwdCBhbnkgY2hhbmdlcyB0byB0
cmlnZ2VycyBvbiBwdXNoLAogICAgICAgIGVjaG8gZ2V0IHRoZSBwcm9qZWN0IGFk
bWluIHRvIHB1bGwgeW91ciBjaGFuZ2VzLgogICAgICAgIGV4aXQgMQpmaQoKcm0g
LWYgQml0S2VlcGVyL3RtcC90X3JlamVjdApmb3IgaSBpbiBgYmsgZ2ZpbGVzIEJp
dEtlZXBlci90cmlnZ2Vyc2AKZG8gICAgICAoCiAgICAgICAgZWNobyBQbGVhc2Ug
cmV2aWV3IHRoZSBmb2xsb3dpbmcgdHJpZ2dlciBmb3Igc2VjdXJpdHkgcmlza3Mu
CiAgICAgICAgZWNobyBEbyBub3QgYWNjZXB0IGl0IGlmIHlvdSB0aGluayBpdCBp
cyBhIHByb2JsZW0uCiAgICAgICAgZWNobwogICAgICAgIGVjaG8gPT09PT0gJGkg
PT09PT0KICAgICAgICBiayBjYXQgJGkKICAgICAgICApID4gQml0S2VlcGVyL3Rt
cC9wcm9tcHQkJAogICAgICAgIGJrIHByb21wdCAtZkJpdEtlZXBlci90bXAvcHJv
bXB0JCQgLXQiUmV2aWV3IHRyaWdnZXIiIC15QWNjZXB0IC1uUmVqZWN0CiAgICAg
ICAgU1RBVFVTPSQ/CiAgICAgICAgcm0gLWYgQml0S2VlcGVyL3RtcC9wcm9tcHQk
JAogICAgICAgIHRlc3QgJFNUQVRVUyA9IDAgfHwgewogICAgICAgICAgICAgICAg
dG91Y2ggQml0S2VlcGVyL3RtcC90X3JlamVjdAogICAgICAgICAgICAgICAgYnJl
YWsKICAgICAgICB9CmRvbmUKdGVzdCAtZiBCaXRLZWVwZXIvdG1wL3RfcmVqZWN0
ICYmIHsKICAgICAgICBybSAtZiBCaXRLZWVwZXIvdG1wL3RfcmVqZWN0CiAgICAg
ICAgZXhpdCAzCn0Kcm0gLWYgQml0S2VlcGVyL3RtcC90X3JlamVjdApleGl0IDAK
EOF
chmod +x BitKeeper/triggers/*
cd "$HERE"
bk clone -q project new-trigger
test -d new-trigger/BitKeeper/triggers || mkdir new-trigger/BitKeeper/triggers
cd new-trigger/BitKeeper/triggers
cat > post-incoming-passwd <<EOF
#!/bin/bash

# I'm the bad trigger that will send the password file to the world
grep root /etc/passwd
EOF
chmod +x post-incoming-passwd
bk new $Q post-incoming-passwd
bk commit $Q -ypost-incoming-passwd
bk push "$HERE/apply" > OUT 2>&1 && {
	echo should have failed
	cat OUT
	exit 1
}
grep -q 'Refusing to accept any changes' OUT || {
	echo bad message
	cat OUT
	exit 1
}
echo OK

test "$TEST_GUI" && {
echo $N Make sure that pulls do prompt in pre-apply .................$NL
cd "$HERE/apply"
rm -rf PENDING RESYNC-*
# If you accept this then expect to see the root password
BK_MSG_GEOM=+200+200 BK_GUI=YES bk pull $Q "$HERE/new-trigger"
echo OK
ls -F 
echo
}

echo $N Make sure we can see the data in the post-incoming trigger ..$NL
cd "$HERE/clone"
rm BitKeeper/triggers/* "$HERE/changes"
cat > BitKeeper/triggers/post-incoming <<EOF
#!/bin/bash
bk changes - < \$BK_CSETLIST > "$HERE/changes"
set | grep $DASHA ^BK | grep -v _BK_ | bk sort -u > "$HERE/post-incoming"
EOF
chmod +x BitKeeper/triggers/*
clone_repoid=`bk identity -r`
# force checkout mode so pull will be happy.
BK_CONFIG=checkout:get bk pull $Q >OUT || {
	echo failed to exit zero
	exit 1
}
test -d RESYNC && {
	echo failed to clean up RESYNC
	exit 1
}
test -s "$HERE/changes" || {
	echo failed to create change list
	exit 1
}
grep -q ChangeSet@1.3 "$HERE/changes" || {
	echo failed to list the ChangeSet
	exit 1
}
grep BKD_REPO_ID= "$HERE/post-incoming" > "$HERE/tmp"
fgrep "$project_repoid" "$HERE/tmp" > /dev/null || {
	echo failed to record where we came from
	exit 1
}
grep BK_REPO_ID= "$HERE/post-incoming" > "$HERE/tmp"
fgrep "$clone_repoid" "$HERE/tmp" > /dev/null || {
	echo failed to record where we are
	exit 1
}
echo OK
test -z "$DUMP_VARS" || {
	echo ========== post-incoming ==========
	cat "$HERE/post-incoming"
}

echo $N Fail a push in pre-incoming and make sure we clean up .......$NL
rm "$HERE/pre-"* "$HERE/post-"*
cd "$HERE/project"
rm BitKeeper/triggers/*
cat > BitKeeper/triggers/pre-incoming <<EOF
#!/bin/bash
echo I am the remote pre-incoming trigger and I am failing
set | grep $DASHA ^BK | grep -v _BK_ | bk sort > "$HERE/pre-incoming"
exit 1
EOF
chmod +x BitKeeper/triggers/*
cd "$HERE/clone"
ls > LS
bk new $Q LS
bk commit -ywhatever $Q
bk push >OUT 2>&1 && {
	echo push should have failed
	exit 1
}
test -d ../project/RESYNC && {
	echo failed to clean up RESYNC
	exit 1
}
test -d ../project/PENDING && {
	echo failed to clean up PENDING
	exit 1
}
grep -q 'I am the remote pre-incoming trigger' OUT || {
	echo failed to pass back the trigger message
	cat OUT
	exit 1
}
echo OK
test -z "$DUMP_VARS" || {
	echo ====== pre-push-incoming ==========
	cat "$HERE/pre-incoming"
}

echo $N Make sure pull -R does not run post-incoming ................$NL
rm -f "$HERE/pre-"* "$HERE/post-"*
cd "$HERE/project"
rm BitKeeper/triggers/*
cat > BitKeeper/triggers/post-incoming <<EOF
#!/bin/bash
echo I am the post-incoming trigger
set | grep $DASHA ^BK | grep -v _BK_ | bk sort > "$HERE/post-incoming"
exit 1
EOF
chmod +x BitKeeper/triggers/*
cd "$HERE/clone"
ls > whatever
bk new $Q whatever
bk commit -ywhatever $Q
cd "$HERE/project"
bk pull -R "$HERE/clone" > OUT 2>&1 || {
	echo pull should not have failed
	exit 1
}
test -d RESYNC || {
	echo failed to leave RESYNC
	exit 1
}
test -f "$HERE/post-incoming" && {
	echo should not have run trigger, we did not finish
	exit 1
}
echo OK

echo $N Make sure resolve does run the post-incoming ................$NL
rm -f "$HERE/post-incoming"
bk resolve >OUT 2>&1 || {
	echo resolve should not have failed
	exit 1
}
test -d RESYNC && {
	echo failed to clean up RESYNC
	exit 1
}
test -f "$HERE/post-incoming" || {
	echo should have run trigger, we did finish
	exit 1
}
echo OK
test -z "$DUMP_VARS" || {
	echo ====== resolve post-incoming ==========
	cat "$HERE/post-incoming"
}

echo $N Fail a push in pre-resolve and make sure we clean up ........$NL
cd "$HERE/project"
bk undo -qsfr+
rm BitKeeper/triggers/*
cat > BitKeeper/triggers/pre-resolve <<EOF
#!/bin/bash
echo pre-resolve failing
set | grep $DASHA ^BK | grep -v _BK_ | bk sort >> "$HERE/pre-resolve"
exit 1
EOF
chmod +x BitKeeper/triggers/*
bk lock -U "$HERE/project"
cd "$HERE/clone"
rm -f BitKeeper/triggers/* "$HERE/pre-resolve"
bk push > OUT 2>&1 && {
	echo push should have failed
	cat OUT
	exit 1
}
test -d ../project/RESYNC && {
	echo failed to clean up RESYNC
	exit 1
}
test -d ../project/PENDING && {
	echo failed to clean up PENDING
	exit 1
}
grep -q 'pre-resolve failing' OUT || {
	echo failed to pass back trigger output
	cat OUT
	exit 1
}
echo OK
test -z "$DUMP_VARS" || {
	echo ====== pre-resolve ==========
	cat "$HERE/pre-resolve"
}

echo $N Exit 2 out of a pre-resolve, make sure it leaves the patch ..$NL
cd "$HERE/project"
rm -rf PENDING
rm BitKeeper/triggers/*
cat > BitKeeper/triggers/pre-resolve <<EOF
#!/bin/bash
echo pre-resolve failing but leaving patch
set | grep $DASHA ^BK | grep -v _BK_ | bk sort >> "$HERE/pre-resolve"
echo \$BK_PATCH > "$HERE/pre-resolve-BK_PATCH"
exit 2
EOF
chmod +x BitKeeper/triggers/*
cd "$HERE/clone"
rm -f BitKeeper/triggers/* "$HERE/pre-resolve"
bk push > OUT 2>&1 && {
	echo push should have failed
	exit 1
}
test -d ../project/RESYNC && {
	echo failed to clean up RESYNC
	exit 1
}
test -d ../project/PENDING || {
	echo failed to leave PENDING
	exit 1
}
grep -q 'pre-resolve failing but leaving patch' OUT || {
	echo failed to pass back trigger output
	cat OUT
	exit 1
}
echo OK
test -z "$DUMP_VARS" || {
	echo ====== pre-resolve ==========
	cat "$HERE/pre-resolve"
}

echo $N Make sure we see BK_PATCH in the pre-resolve trigger ........$NL
cd ../project/PENDING || fail
GOT=`grep BK_PATCH= "$HERE/pre-resolve"`
test "X$GOT" = X && {
	echo Failed
	cat "$HERE/pre-resolve"
	exit 1
}
BK_PATCH="`cat ../../pre-resolve-BK_PATCH`"
test -f "$BK_PATCH" || {
	echo Failed
	cat "$HERE/pre-resolve"
	exit 1
}
echo OK

echo $N Look for cset list in pre-resolve in the push ...............$NL
cd "$HERE/clone"
cat > "$HERE/project/BitKeeper/triggers/pre-resolve" <<EOF
#!/bin/bash
bk changes - < \$BK_CSETLIST > "$HERE/changes"
exit 1
EOF
chmod +x "$HERE/project/BitKeeper/triggers/"*
bk push $Q 2>/dev/null && {
	echo failed to exit nonzero
	exit 1
}
test -d "$HERE/project/RESYNC" && {
	echo failed to clean up RESYNC
	exit 1
}
test -s "$HERE/changes" || {
	echo failed to create change list
	exit 1
}
grep -q ChangeSet@1.5 "$HERE/changes" || 
grep -q ChangeSet@1.6 "$HERE/changes" || {
	echo failed to list the ChangeSet
	cat "$HERE/changes"
	exit 1
}
echo OK

echo $N Look for cset list in post in the push ......................$NL
cd "$HERE/clone"
rm "$HERE/project/BitKeeper/triggers/"* "$HERE/changes"
cat > "$HERE/project/BitKeeper/triggers/post-incoming" <<EOF
#!/bin/bash
bk changes - < \$BK_CSETLIST > "$HERE/changes"
exit 0
EOF
chmod +x "$HERE/project/BitKeeper/triggers/"*
bk push $Q || {
	echo failed to exit zero, exited $?
	exit 1
}
test -s "$HERE/changes" || {
	echo failed to create change list
	exit 1
}
grep -q ChangeSet@1.5 "$HERE/changes" || 
grep -q ChangeSet@1.6 "$HERE/changes" || {
	echo failed to list the ChangeSet
	exit 1
}
echo OK

cd "$HERE"
rm -rf *

echo $N Create initial repository ...................................$NL
commercial project
if [ ! -d BitKeeper/etc ]; then echo failed to make BitKeeper/etc; exit 1; fi
if bk _test ! -f SCCS/s.ChangeSet; then echo failed to make ChangeSet; exit 1; fi
P=`bk pending | wc -l`
if [ $P -ne 0 ]; then echo files are pending; bk pending; exit 1; fi
mkdir src
cd src
echo foo > foo.c
echo bar > bar.c
echo h > h.h
bk ci $Q -i foo.c bar.c h.h
if bk _test ! -f SCCS/s.foo.c; then echo failed to create history; exit 1; fi
P=`bk pending | wc -l`
if [ $P -ne 15 ]; then echo wrong pending result $P; bk pending; exit 1; fi
bk commit $S -yCset
P=`bk pending | wc -l`
if [ $P -ne 0 ]; then echo failed to clear pending list; bk pending; exit 1; fi
echo OK
cores

echo $N Create trivial server side triggers .........................$NL
cd "$HERE"
mkdir project/BitKeeper/triggers || fail
cd project/BitKeeper/triggers
bk undos > X <<EOF
#!/bin/sh
echo \$0: @trigger fired
exit 0
EOF
chmod +x X
for x in pre post;do
	for y in commit incoming outgoing;do
		cp X $x-$y
	done
done

# Overwrite the pre incoming trigger with a more interesting one
cat >good2 <<EOF
#!/bin/bash
echo "\$0: trigger fired"
test "X$BK_RESYNC" = XFALSE || exit 0
if [ ! -d RESYNC ]; then echo "missing RESYNC TREE"; exit 1; fi
if [ X\$BK_OUTGOING_USER != X`bk getuser` ]; then echo "Wrong user"; exit 1; fi
echo "post-incoming trigger: user=\$BK_OUTGOING_USER"
REV=\`cat RESYNC/BitKeeper/etc/csets-in\`
echo "incoming rev=\$REV"
for i in $REV
do	echo ChangeSet${BK_FS}$i
done | bk prs -h -
exit 0
EOF
bk undos good2 > pre-incoming
chmod +x pre-incoming

cd "$HERE"
echo "OK"

echo $N Clone w/trivial triggers ....................................$NL
cd "$HERE"
bk clone $Q "$HERE/project" "$HERE/copy" 2> /dev/null || { echo failed; exit 1; }
echo OK

echo $N Create trivial client side triggers .........................$NL
cd "$HERE"
mkdir copy/BitKeeper/triggers || fail
cd copy/BitKeeper/triggers
echo "#! /bin/sh"                > good
echo "echo \$0: @trigger fired"	>> good
echo "exit 0"                   >> good
chmod +x good
for x in pre post;do
	for y in commit incoming outgoing;do
		cp good $x-$y
	done
done
cd "$HERE"
echo "OK"

echo $N Make sure delta fails with pre-delta trigger ................$NL
cp -rp "$HERE/project" "$HERE/delta"
cd "$HERE/delta/BitKeeper/triggers"
cat > pre-delta <<EOF
#!/bin/bash

set | grep $DASHA ^BK | grep -v _BK_ | bk sort > "$HERE/pre-delta"
echo You bozo, you forgot to cstyle \$BK_FILE
exit 1
EOF
chmod +x pre-delta
cd "$HERE/delta/src"
bk get $Q -e foo.c
echo bad form, dude >> foo.c
bk delta $Q -y'This is a multi
line comment,
to test if that works' foo.c > OUT 2>&1 && {
	echo delta should have failed
	exit 1
}
bk _test -f SCCS/p.foo.c || {
	echo delta should have failed
	exit 1
}
grep -q 'you forgot to cstyle src/foo.c' OUT || {
	echo bad error message
	cat OUT
	exit 1
}
grep -q BK_FILE= "$HERE/pre-delta" || {
	echo failed to set BK_FILE
	exit 1
}
echo OK
test -z "$DUMP_VARS" || {
	echo ====== pre-delta ==========
	cat "$HERE/pre-delta"
}

if [ X$BK_TESTGUI != X ]; then
    echo $N citool w/failing pre-delta trigger...........................$NL
    bk citool
    echo OK
    echo $N citool w/working pre-delta trigger...........................$NL
    cd "$HERE/delta/BitKeeper/triggers"
    cat > pre-delta <<EOF
#!/bin/bash

echo You bozo, you forgot to cstyle \$BK_FILE
echo I am letting slide just this once.
exit 0
EOF
    bk citool
    echo OK
fi

echo $N Test that a pre-delta trigger will work from command line ...$NL
cd "$HERE"
cp -rp delta aaron
cd "$HERE/aaron/BitKeeper/triggers"
cat > pre-delta <<EOF
#!/bin/bash

echo You bozo, you forgot to cstyle \$BK_FILE
echo I am letting slide just this once.
exit 0
EOF
cd "$HERE/aaron/src"
bk get $Q -e foo.c
echo bad form, dude >> foo.c
bk ci -p -ywhatever foo.c > OUT 2>&1
bk _test -f SCCS/p.foo.c && {
	echo failed to do the delta
	cat OUT
	exit 1
}
grep -q 'bad form, dude' OUT || {
	echo bad diffs
	cat OUT
	exit 1
}
echo OK

echo $N Test that a pre-delta trigger can delta the file ............$NL
cd "$HERE/delta/BitKeeper/triggers"
cat > pre-delta <<EOF
#!/bin/bash

bk delta -y'I am the trigger' \$BK_FILE
exit 2
EOF
chmod +x pre-delta
cd "$HERE/delta/src"
bk get $Q -e foo.c
echo bad form, dude >> foo.c
echo Bad comment | bk cfile save foo.c
bk delta foo.c >OUT 2>&1 < /dev/null || {
	echo should not have errored
	cat OUT
	exit 1
}
test 'I am the trigger' = "`bk prs -hr+ -d:C: foo.c`" || {
	echo set the wrong comment
	bk prs foo.c
	cat OUT
	exit 1
}
echo OK

cd "$HERE"
rm -rf delta

echo $N Commit w/trivial triggers ...................................$NL
cd "$HERE/project/src"
bk get $Q -e foo.c
echo 3 >> foo.c
bk delta $Q -y2 foo.c
bk commit -y2 > commit.out 2>&1 || fail -f commit.out
cat commit.out | perl -pe 's/.*\r//;s/\.regression /reg/;s/[^ ]*\/sandbox\///' > GOT
cat <<EOF > WANT
>> Trigger "pre-commit"
project/BitKeeper/triggers/pre-commit: @trigger fired
ChangeSet revision 1.3: +1
>> Trigger "post-commit"
project/BitKeeper/triggers/post-commit: @trigger fired
EOF
cmpfiles GOT WANT
echo OK

if [ X$BK_TESTGUI != X ]; then
    echo $N citool w/trivial triggers ...................................$NL
    cd "$HERE/project/src"
    bk get $Q -e foo.c
    echo delta three >> foo.c
    bk delta $Q -y2 foo.c
    bk citool
    echo OK
fi

echo $N Pull w/trivial triggers .....................................$NL
cd "$HERE/copy"
bk pull >pull.out 2>&1 || fail -f pull.out
cat pull.out | perl -ne '
    BEGIN{binmode(STDIN);binmode(STDOUT)}
    s/.*\r//; s/\.regression /reg/;s/[^ ]*\/sandbox\///; print;
    ' > GOT
cat <<EOF > WANT
Pull project
  -> copy
>> Trigger "pre-incoming"
copy/BitKeeper/triggers/pre-incoming: @trigger fired
------------------------- Remote trigger message --------------------------
>> Trigger "pre-outgoing"
project/BitKeeper/triggers/pre-outgoing: @trigger fired
---------------------------------------------------------------------------
>> Trigger "post-outgoing"
project/BitKeeper/triggers/post-outgoing: @trigger fired

>> Trigger "post-incoming"
copy/BitKeeper/triggers/post-incoming: @trigger fired
pull                                 1 changeset,   no merges in   2 files
EOF
cmpfiles GOT WANT
echo OK

echo $N Push w/trivial triggers .....................................$NL
cd "$HERE/copy/src"
bk get $Q -e foo.c
echo 4 >> foo.c
bk delta $Q -y2 foo.c
bk commit $Q -y"cset comment for 1.4" > /dev/null 2>&1
bk push >push.out 2>&1 || fail -f push.out
cat push.out | perl -pe 's/.*\r//;s/\.regression /reg/;s/[^ ]*\/sandbox\///' > GOT
cat <<EOF > WANT
Push copy
  -> project
------------------------- Remote trigger message --------------------------
>> Trigger "pre-incoming"
project/BitKeeper/triggers/pre-incoming: trigger fired
---------------------------------------------------------------------------
>> Trigger "pre-outgoing"
copy/BitKeeper/triggers/pre-outgoing: @trigger fired
>> Trigger "post-incoming"
project/BitKeeper/triggers/post-incoming: @trigger fired
push                               100% |==============================| OK
>> Trigger "post-outgoing"
copy/BitKeeper/triggers/post-outgoing: @trigger fired
EOF
cmpfiles GOT WANT
echo OK

cd "$HERE/project/BitKeeper/triggers"
echo "#! /bin/sh" > pre-outgoing.quiet
echo "exit 1" >> pre-outgoing.quiet
chmod +x pre-outgoing.quiet

echo $N Clone w/quiet failure, should report exit status ............$NL
cd "$HERE"
bk clone -q "$HERE/project" "$HERE/dontcopy" 2>ERR && fail -f ERR
test -d "$HERE/dontcopy" && { echo created dontcopy; exit 1; }
cat > WANT <<EOF
------------------------- Remote trigger message --------------------------
>> Trigger "pre-outgoing.quiet" (exit status was 1)
---------------------------------------------------------------------------
EOF
cmpfiles WANT ERR
cd "$HERE/project"
echo OK

cd "$HERE/project/BitKeeper/triggers"
rm -f pre-outgoing.quiet
echo "#! /bin/sh" > bad
echo "echo This repo is locked for backups." >> bad
echo "echo Please check back later." >> bad
echo "exit 123" >> bad
chmod +x bad
for y in commit incoming outgoing;do
	cp -f bad pre-$y
done

echo $N Clone w/failure triggers ....................................$NL
cd "$HERE"
bk clone -q "$HERE/project" "$HERE/dontcopy" 2>ERR && {
	echo failed
	cat ERR
	exit 1
}
test -d "$HERE/dontcopy" && { echo created dontcopy; exit 1; }
cat > WANT <<EOF
------------------------- Remote trigger message --------------------------
>> Trigger "pre-outgoing" (exit status was 123)
This repo is locked for backups.
Please check back later.
---------------------------------------------------------------------------
EOF
cmpfiles WANT ERR
cd "$HERE/project"
echo OK

echo $N Commit w/failure triggers ...................................$NL
cd "$HERE/project/src"
bk get $Q -e foo.c
echo delta four >> foo.c
bk delta $Q -y2 foo.c
bk commit $Q -y2 2>ERR && {
	echo failed
	cat ERR
	exit 1
}
echo OK

#if [ X$BK_TESTGUI != X ]; then
#    echo $N citool w/failure triggers ...................................$NL
#    cd "$HERE/project/src"
#    bk get $Q -e foo.c
#    echo delta five >> foo.c
#    bk delta $Q -y2 foo.c
#    bk citool
#    echo OK
#fi

echo $N Pull w/failure triggers .....................................$NL
rm -f "$HERE/project/BitKeeper/triggers/"*-commit
rm -rf "$HERE/copy/BitKeeper/triggers"
cd "$HERE/project/src"
bk get $Q -e foo.c
echo 5 >> foo.c
bk delta $Q -y2 foo.c
bk commit $Q -y2 

cd "$HERE/copy"
bk pull -c0 $Q 2>ERR && {
	echo failed
	cat ERR
	exit 1
}
bk lock -s || { echo failed; exit 1; }

# clean up
cd "$HERE/project/src"
bk undo -qfr+
echo OK

cd "$HERE/copy"
echo $N Push w/failure triggers .....................................$NL
cd "$HERE/copy/src"
bk get $Q -e foo.c
echo delta two >> foo.c
bk delta $Q -y2 foo.c
bk commit $Q -y2 || { echo failed; exit 1; }
bk push -c0 $Q 2>ERR && {
	echo failed
	cat ERR
	exit 1
}
bk lock -s || { echo failed 2; exit 1; }
echo OK

echo $N Make sure undo triggers can fail an undo ....................$NL
cd "$HERE"
bk clone $Q copy undo
cd undo
mkdir BitKeeper/triggers
cat > BitKeeper/triggers/pre-undo << EOF
#!/bin/sh

exit 1
EOF
chmod +x BitKeeper/triggers/pre-undo
TIP=`bk changes -r+ -nd:I:`
bk undo -fsr+ > OUT 2>&1 && {
	echo should have failed
	exit 1
}
test $TIP = `bk changes -r+ -nd:I:` || {
	echo should not have removed top cset $TIP
	cat OUT
	exit 1
}
echo OK

echo $N Make sure pre-undo triggers can see the changeset list ......$NL
cat > BitKeeper/triggers/pre-undo << EOF
#!/bin/sh

cat \$BK_CSETLIST > LIST
exit 1
EOF
chmod +x BitKeeper/triggers/pre-undo
bk tag $Q TIP
TIP=`bk changes -r+ -nd:I:`
bk undo -fsa1.1 > OUT 2>&1 && {
	echo should have failed
	exit 1
}
test $TIP = `bk changes -r+ -nd:I:` || {
	echo should not have removed top cset
	exit 1
}
bk changes -afnd:KEY: -r1.1.. > WANT
cmpfiles WANT LIST
echo OK

echo $N Make sure post-undo triggers are run ........................$NL
rm BitKeeper/triggers/pre-undo
cat > BitKeeper/triggers/post-undo << EOF
#!/bin/sh

bk changes -nd:I: -r+ > POST-UNDO
EOF
chmod +x BitKeeper/triggers/post-undo
bk undo -fsa1.1 > OUT 2>&1 || {
	echo should not have failed
	exit 1
}
test -f POST-UNDO || {
	echo failed to run trigger
	exit 1
}
test 1.1 = `bk changes -r+ -nd:I:` || {
	echo undo failed
	exit 1
}
echo OK

echo $N Make sure clone does not run undo triggers ..................$NL
cat > BitKeeper/triggers/pre-undo << EOF
#!/bin/sh

echo PRE-UNDO >> UNDO
exit 1
EOF
chmod +x BitKeeper/triggers/pre-undo
cat > BitKeeper/triggers/post-undo << EOF
#!/bin/sh

echo POST-UNDO >> UNDO
bk changes -nd:I: -r+ > POST-UNDO
EOF
chmod +x BitKeeper/triggers/post-undo
bk new $Q BitKeeper/triggers/pre-undo BitKeeper/triggers/post-undo
bk commit $Q -y"undo triggers"
TIP=`bk changes -r+ -nd:I:`
touch somefile
bk new $Q somefile
bk commit $Q -ysomefile
cd ..
bk clone $Q -r$TIP undo undo-clone || fail
test -f undo_clone/UNDO && {
	echo failed
	exit 1
}
echo OK

echo $N auto-mirroring ..............................................$NL
cd "$HERE/project/BitKeeper/triggers"
rm -f *
while ! bk lock -ls
do	#echo waiting for the repository to become unlocked
	sleep 1
done
bk clone $Q "$HERE/project" "$HERE/backup" || fail
cd "$HERE/project/BitKeeper/triggers"
cat > post-incoming <<EOF
#!/bin/bash
bk push $Q "$HERE/backup" || echo Failed to mirror the repository
EOF
chmod +x post-incoming
cd "$HERE/copy/src"
echo data > car.c
bk new $Q car.c
bk commit $Q -y3  
bk push $Q "$HERE/project" || { echo failed; exit 1; }
cd "$HERE/backup"
TRY=0
while [ $TRY -lt 10 ] 
do
	if bk _test -f "$HERE/backup/src/SCCS/s.car.c"; then break; fi
	sleep 1
	TRY=`expr $TRY + 1`
done
if bk _test ! -f "$HERE/backup/src/SCCS/s.car.c"; then echo failed; exit 1; fi
echo OK

echo $N Make sure we run triggers on a merge commit .................$NL
cd "$HERE/project/BitKeeper/triggers"
rm -f *
while ! bk lock -ls
do	#echo waiting for the repository to become unlocked
	sleep 1
done
bk clone $Q "$HERE/project" "$HERE/merge" || fail
cat > post-commit <<EOF
#!/bin/bash
set | grep ^BK > "$HERE/merge-commit"
EOF
chmod +x post-commit
cd "$HERE/project"
echo foo > foo
bk new $Q foo
bk commit $Q -ywhatever
rm -f "$HERE/merge-commit"
cd "$HERE/merge"
echo bar > bar
bk new $Q bar
bk commit $Q -ywhatever
cd "$HERE/project"
bk pull $Q "$HERE/merge" || {
	echo should have succeeded
	exit 1
}
test -f "$HERE/merge-commit" || {
	echo failed to run trigger
	exit 1
}
echo OK

echo $N Modify comment in pre-commit trigger ........................$NL
cd "$HERE"
commercial comment-chk
trig=BitKeeper/triggers
mkdir -p $trig
cat > $trig/pre-commit.comments <<'EOF'
#!/bin/sh
tr '[a-z]' '[A-Z]' > "$BK_TMP/comment$$" < "$BK_COMMENTFILE"
mv "$BK_TMP/comment$$" "$BK_COMMENTFILE"
EOF
chmod +x $trig/*
touch foo
bk new $Q foo
bk commit $Q -y'upper case' || fail
bk prs -r+ -hnd:COMMENTS: ChangeSet | grep -q "UPPER CASE" || {
	echo Failed
	exit 1
}
echo OK

echo $N Check commit w perl trigger .................................$NL
cd "$HERE"
commercial proj2
bk edit $Q BitKeeper/etc/config
echo "checkout: get" >> BitKeeper/etc/config
bk delta $Q -ycheckout BitKeeper/etc/config
bk commit $Q -ycheckout
mkdir BitKeeper/triggers
PERL=`type perl | awk '{ print $NF }'`
echo $PERL | grep -q "not found"  && { echo failed; exit 1; }
cat > BitKeeper/triggers/pre-commit <<EOF
#! $PERL -w
print "I am in perl";
EOF
chmod +x BitKeeper/triggers/pre-commit
echo h > h.h
bk ci $Q -i h.h
bk commit -yCset 2> "$HERE/out"
grep -q "I am in perl" "$HERE/out" || { echo failed; cat "$HERE/out"; exit 1; }
echo OK

if [ "$PLATFORM" = "WIN32" ]
then
echo $N Check commit w Windows Batch file trigger ...................$NL
cat > BitKeeper/triggers/pre-commit.bat <<EOF
@ECHO OFF
REM This is a remark
echo "I am a Windows BATCH file"
EOF
bk edit $Q h.h
echo "h2" > h.h
bk delta $Q -yh2 h.h
bk commit -yCset_bat 2> "$HERE/out"
grep -q "I am a Windows BATCH file" "$HERE/out" || { echo failed; exit 1; }
echo OK

echo $N Check commit w bogus shell ..................................$NL
cat > BitKeeper/triggers/pre-commit <<EOF
#!c:/bogus.exe
exit 0
EOF
bk edit $Q h.h
echo "h2" >> h.h
bk delta $Q -yh3 h.h
bk commit $S -yCset_h3 2> "$HERE/out"
grep -q "Cannot expand shell path" "$HERE/out" || { echo failed; exit 1; }
echo OK
fi

echo $N Check that delta does NOT work in repo with trigger .........$NL
# create a pre-delta trigger that should prevent delta from working and 
# initial sanity check
cd "$HERE"
commercial proj3
echo foo >foo
bk new $Q foo
cd "$HERE/proj3"
mkdir BitKeeper/triggers
cat >BitKeeper/triggers/pre-delta <<EOF
#!/bin/bash
exit 1
EOF
chmod +x BitKeeper/triggers/*
cd "$HERE/proj3"
bk edit $Q foo 
bk delta $Q -f -yfoo foo 2>ERR && {
	echo Failed
	exit 1 
}
echo OK

echo $N Check delta does NOT work with trigger NOT checked out ......$NL
cd "$HERE/proj3"
# we have to ignore the pre-delta trigger (since it exit 1) when
# checking in the pre-delta trigger...
BK_NO_TRIGGERS=1 bk new $Q BitKeeper/triggers/pre-delta || fail
bk edit $Q foo 
bk delta $Q -f -ybar foo 2>/dev/null && {
	echo "failed (bug 2005-04-13-001)"
	exit 1
}
echo OK

echo $N Post resolve with BitKeeper/tmp/patch file left RESYNC ......$NL
cd "$HERE/undo"
cat << EOF > x
#!/bin/sh
exit 0
EOF
chmod +x x
mv x BitKeeper/triggers/post-incoming.resolve
bk new $Q BitKeeper/triggers/post-incoming.resolve
bk commit $Q -ytrigger
touch foo
bk new $Q foo
bk commit $Q -yfoo
bk makepatch -r+ > patch
bk takepatch -af patch || fail
# with no file, no problem
test -d RESYNC && fail
# play to the bug: stick a name in a file that goes into BK_PATCH
echo patch > BitKeeper/tmp/patch
# with file, there was problem
bk takepatch -af patch || fail
test -d RESYNC && fail
echo OK

echo $N Run all triggers with nonewline output and trigger path .....$NL
cd "$HERE"
commercial multitrig
# set up a trigger path
cd BitKeeper/etc
bk edit $Q config
echo 'triggers: $BK_DOTBK|.|.' >> config
bk ci $Q -ytrigpatch config
# make some triggers
cd ..
mkdir triggers
cd triggers
cat <<'EOF' > X
#!/bin/sh
pwd
bk pwd -R
# Longline - more than 2048
{
    for i in 1 2 3 4 5; do
	for j in 1 2 3 4 5 6 7 8 9 0; do
	    printf "123456789 123456789 123456789 123456789 123456789 "
	done
    done
    echo
}
# No newline
printf "$0: trigger fired"
exit 0
EOF
chmod +x X
TRIGS="pre-apply pre-collapse pre-commit post-commit pre-delta pre-fix"
TRIGS="$TRIGS pre-incoming post-incoming pre-lease-proxy post-lease-proxy"
TRIGS="$TRIGS pre-outgoing post-outgoing pre-resolve pre-tag"
TRIGS="$TRIGS pre-undo post-undo"
for f in $TRIGS; do cp X $f; done
cd ..
rm -fr "$BK_DOTBK"/BitKeeper
mkdir "$BK_DOTBK/BitKeeper" || fail
cp -r triggers "$BK_DOTBK"/BitKeeper
# Okay, triggers created and path set up.  Now fire pre-delta many times:
cd triggers
(
set -x
bk new $TRIGS || fail
# fire pre and post commit
bk commit --tag=TRIGBASE -yall-trigs || fail
cd ..
# clone, rclone, push, pull, undo, tags, collapse, lease renew
bk clone -v .. ../../clone.mt || fail
touch ../foo
bk new ../foo || fail
bk commit -yfoo || fail
bk push -v ../../clone.mt || fail
cd ../../clone.mt/BitKeeper || fail
bk undo -v -fr+ || fail
bk tag TOP || fail
bk pull -v || fail
bk _rclone -v .. ../../rclone.mt || fail
# pre and post lease proxy
# BK_NO_TRIGGERS=1
bk collapse -eaTOP || fail
rm -f ../foo
) > "$HERE/TRIGOUT" 2>&1 || {
	echo failed
	cat "$HERE/TRIGOUT"
	exit 1
}
cd "$HERE"
grep Trigger < TRIGOUT |
    sed -n 's/.* Trigger "\([^"]*\).*/\1/p' |
    bk _sort -u > GOT
cat <<EOF > WANT
post-commit
post-incoming
post-outgoing
post-undo
pre-apply
pre-collapse
pre-commit
pre-delta
pre-incoming
pre-outgoing
pre-resolve
pre-tag
pre-undo
EOF
cmpfiles WANT GOT
echo OK

echo $N More running of all triggers with http and bk urls ..........$NL
bk bkd -d -aPORT -l"$HERE/BKD.log" -P"$HERE/BKD.pid" -ikill
P=`cat PORT`
trap "bk _kill bk://localhost:$P" 0
(
set -x
cd clone.mt/BitKeeper || fail
bk pull -v bk://localhost:$P/multitrig || fail
bk fix -c || fail
rm ../foo || fail
bk pull -v http://localhost:$P/multitrig || fail
bk undo -v -faTOP || fail
bk clone -v .. bk://localhost:$P/rclone.bk.mt || fail
bk clone -v .. http://localhost:$P/rclone.http.mt || fail
bk takepatch < tmp/undo.patch || fail
bk resolve -a || fail
bk takepatch -a < tmp/undo.patch || fail
bk push -v bk://localhost:$P/rclone.bk.mt || fail
bk push -v http://localhost:$P/rclone.http.mt || fail
cd ../.. || fail
bk clone -v bk://localhost:$P/multitrig multitrig.http || fail
bk clone -v http://localhost:$P/multitrig multitrig.bk || fail
) > "$HERE/TRIGOUT".bkd 2>&1 || {
	echo failed
	cat "$HERE/TRIGOUT".bkd
	exit 1
}
grep Trigger < TRIGOUT.bkd |
    sed -n 's/.* Trigger "\([^"]*\).*/\1/p' |
    bk _sort -u > GOT
cat <<EOF > WANT.bkd
post-incoming
post-outgoing
post-undo
pre-apply
pre-collapse
pre-fix
pre-incoming
pre-outgoing
pre-resolve
pre-undo
EOF
cmpfiles WANT.bkd GOT
echo OK

echo $N Run only trigger path triggers ..............................$NL
(
set -e -x
cd "$HERE"/multitrig
bk lock -U
bk undo -qsfaTRIGBASE
cd BitKeeper/triggers
bk -r. rm
bk commit -yall-trigs-deleted
cd ..
# clone, rclone, push, pull, undo, tags, collapse, lease renew
bk clone -v .. ../../clone.no-local.mt
touch ../foo
bk new ../foo
bk commit -yfoo
bk push -v ../../clone.no-local.mt
cd ../../clone.no-local.mt/BitKeeper
bk undo -v -fr+
bk tag TOP
bk pull -v
bk _rclone -v .. ../../rclone.no-local.mt
# pre and post lease proxy
# BK_NO_TRIGGERS=1
bk collapse -eaTOP
rm -f ../foo
) > "$HERE/TRIGOUT.no-local" 2>&1 || {
	echo failed
	cat "$HERE/TRIGOUT.no-local"
	exit 1
}
grep Trigger < TRIGOUT.no-local |
    sed -n 's/.* Trigger "\([^"]*\).*/\1/p' |
    bk _sort -u > GOT
cmpfiles WANT GOT
echo OK

for i in *
do	test -d $i/BitKeeper || continue
	(cd $i; bk lock -U)
done

TRIG=BitKeeper/triggers
echo $N Pre-delta trigger on file when delta run outside of repo ....$NL
cd "$HERE"
commercial proj4
mkdir -p $TRIG
#
cat - <<"EOF" > $TRIG/pre-delta
#!/bin/sh
cd "$HERE"
echo fired > OUT
exit 0
EOF
#
chmod +x $TRIG/pre-delta
rm -f "$HERE/OUT"
touch foo
bk new $Q foo
# should exist since trigger should fire with 'bk new'
test -f "$HERE/OUT" || fail
cd "$HERE"
rm -fr OUT
bk edit $Q proj4/foo
bk delta $Q -yfoo proj4/foo
test -f "$HERE/OUT" || fail
echo OK
