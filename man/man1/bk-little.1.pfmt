.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "bk little 1"
.TH "bk little" 1 "2016-04-16" "oss" "BitKeeper Users Manual"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "Name"
.IX Header "Name"
Little
.SH "Synopsis"
.IX Header "Synopsis"
L [options] script.l [args]
.SH "Introduction"
.IX Header "Introduction"
bk little, or Little, is a compiled-to-byte-code language that draws heavily from C
and Perl.  From C, Little gets C syntax, simple types (int, float, string),
and complex types (arrays, structs).  From Perl, Little gets associative
arrays and regular expressions (\s-1PCRE\s0).  And from neither, Little gets its
own simplistic form of classes.
.PP
The name \*(L"Little\*(R", abbreviated as simply \*(L"L\*(R", alludes to the language's
simplicity. The idea was to distill
the useful parts of other languages and combine them into a scripting
language, with type checking, classes (not full-blown \s-1OO\s0 but useful none
the less), and direct access to a cross-platform graphical toolkit.
.PP
Little provides a set of built-in functions, drawn from Perl and the 
standard C library.
.PP
Little is built on top of the Tcl/TK system.
The Little compiler generates Tcl byte codes and uses the Tcl
calling convention.
This means that L and Tcl code may be intermixed.
More importantly, it means that Little may use all of the Tcl \s-1API\s0
and libraries as well as \s-1TK\s0 widgets.
The net result is a type-checked scripting language which may be
used for cross-platform GUIs.
.PP
Little is open source under the same license as Tcl/TK (\s-1BSD\s0 like)
with any bits that are unencumbered by the Tcl license also being
available under the Apache License, Version 2.0.
.SH "Running Little programs"
.IX Header "Running Little programs"
You can run a Little program from the command line.
.PP
.Vb 1
\&    bk little [options] progname.l [args]
.Ve
.PP
Alternatively, put this as the first line of your script, but make
sure your script is executable (\f(CW\*(C`chmod 755 script.l\*(C'\fR under Unix).
.PP
.Vb 1
\&    #!/path/to/L [options]
.Ve
.PP
Options:
.IP "\fB\-\-fnhook=myhook\fR" 4
.IX Item "--fnhook=myhook"
When function tracing is enabled, use \f(CW\*(C`myhook\*(C'\fR as the trace hook.
.IP "\fB\-\-fntrace=on | entry | exit | off\fR" 4
.IX Item "--fntrace=on | entry | exit | off"
Enable function tracing on both function entry and exit, entry only,
exit only, or disable tracing altogether.
.IP "\fB\-\-norun\fR" 4
.IX Item "--norun"
Compile only (do not run).  This is useful to check for compilation
errors.
.IP "\fB\-\-nowarn\fR" 4
.IX Item "--nowarn"
Disable compiler warnings.  This is useful when you know you have
unused variables or other warnings that you don't want to be
bothered with.
.IP "\fB\-\-poly\fR" 4
.IX Item "--poly"
Treat all types as \f(CW\*(C`poly\*(C'\fR.  This effectively disables type checking.
.IP "\fB\-\-trace\-depth=n\fR" 4
.IX Item "--trace-depth=n"
When function tracing is enabled, trace only to a maximum call depth of n.
.IP "\fB\-\-trace\-files=colon\-separated list of glob | /regexpr/\fR" 4
.IX Item "--trace-files=colon-separated list of glob | /regexpr/"
Enable tracing of all functions in the given files, specified either
as globs or regular expressions.  A leading + before a glob or regexp
means to add to what is otherwise being traced and a leading \- means
to remove.
No leading + or \- means to trace exactly what is specified.
.IP "\fB\-\-trace\-funcs=colon\-separated list of glob | /regexpr/\fR" 4
.IX Item "--trace-funcs=colon-separated list of glob | /regexpr/"
Like \-\-trace\-files but specifies functions.
.IP "\fB\-\-trace\-out=filename | host:port\fR" 4
.IX Item "--trace-out=filename | host:port"
Send default trace output to a file or a \s-1TCP\s0 socket.
.IP "\fB\-\-version\fR" 4
.IX Item "--version"
Print the L build version and immediately exit.
.PP
The tracing-related command-line options also can be specified in a #pragma
inside the program; see the \s-1DEBUGGING\s0 section.
.PP
The optional [args] is a white-space separated list of arguments that
are passed to the script's \fImain()\fR function as an
array of strings (argv).
.SH "Language syntax"
.IX Header "Language syntax"
A Little script or program consists of one or more statements.  These may
be executable statements, variable or type declarations, function
or class declarations, or #pragma statements which specify tracing
directives.  Statements outside of functions are said
to be at the \f(CW\*(C`top level\*(C'\fR and are executed in the order they appear,
although you can use a \f(CW\*(C`return\*(C'\fR statement to bail out.
There is no need to have a \f(CW\*(C`main()\*(C'\fR function, but if one is
present, it is executed after all of the top-level statements
(even if you did a \f(CW\*(C`return\*(C'\fR from the top level).
.PP
.Vb 6
\&    puts("This is printed first.");
\&    void main()
\&    {
\&        puts("This is printed last.");
\&    }
\&    puts("This is printed second.");
.Ve
.PP
Little statements end in a semi-colon.
.PP
.Vb 1
\&    printf("Hello, world\en");
.Ve
.PP
Both C style and hash style comments are allowed, but the hash-style
comments are only for the first line and must start on column 1.
.PP
.Vb 4
\&    # This is a comment
\&        // So is this
\&    /* And this too */
\&        # But this is an error, only allowed on column 1, line 1
.Ve
.PP
Whitespace usually is irrelevant.
.PP
.Vb 3
\&    printf(
\&        "Hello, world\en")
\&        ;
.Ve
.PP
\&... except inside quoted strings:
.PP
.Vb 3
\&    # this would print with a linebreak in the middle
\&    printf("Hello\e
\&    world\en");
.Ve
.PP
and around the string-concatenation operator \*(L" . \*(R" so it can
be distinguished from the struct-member selection operator \*(L".\*(R".
.PP
Double quotes or single quotes may be used around literal strings:
.PP
.Vb 2
\&    puts("Hello, world");
\&    puts(\*(AqHello, world\*(Aq);
.Ve
.PP
However, only double quotes \*(L"interpolate\*(R" variables and handle
character escapes such as for newlines (\f(CW\*(C`\en\*(C'\fR):
.PP
.Vb 2
\&    puts("Hello, ${name}");     // works fine
\&    puts(\*(AqHello, ${name}\*(Aq);     // prints ${name}\en literally
.Ve
.PP
Inside single quotes, you can still escape a line break, the
single quote character (\f(CW\*(C`\e\*(Aq\*(C'\fR), and the escape character (\f(CW\*(C`\e\e\*(C'\fR).
.PP
.Vb 3
\&    puts(\*(AqHere \e\*(Aq and \e\e are escaped.\*(Aq);
\&    puts(\*(AqThis one spans a\e
\&    line\*(Aq);
.Ve
.PP
If you put a line break in the middle of a string but forget to escape
it, Little will complain.
.PP
Adjacent string constants are automatically concatenated, like in C.
.PP
.Vb 3
\&    printf("This " "prints "
\&           "the concatenation "
\&           "of ""all"" strings\en");
.Ve
.PP
prints \*(L"This prints the concatenation of all strings\*(R" followed by a
newline.
.PP
Little requires that they be the same \*(L"type\*(R", all interpolated ("") or
all not interpolated ('') but the dot operator comes the rescue
in this contrived example:
.PP
.Vb 1
\&    \*(AqHi there. ${USER} is \*(Aq . "${USER} today"
.Ve
.SH "Variables, types, and constants"
.IX Header "Variables, types, and constants"
Little is a statically typed language with both scalar and complex types.
All variables are typed and must be declared before use.
.PP
The scalar types are int, float, and string.  The complex types are
array, hash, struct, and list.  Little also supports function pointers,
classes, and a special type called \f(CW\*(C`poly\*(C'\fR which matches any type and
normally is used to disable type checking.  Finally, Little has the concept
of an \f(CW\*(C`undefined\*(C'\fR value which a variable of any type can possess.
.PP
Strong typing means that you can assign something of one type only to
something else of a compatible type.  Normally, to be compatible the
types must be structurally the same, but there are exceptions such as
an int being compatible with float and a list sometimes being
compatible with an array or struct.
.PP
Variables begin with a letter and can
contains letters, numerals, and underscores, but they \fBcannot\fR begin
with an underscore (_).  This is because the Little compiler reserves names
starting with _ for internal use.
.PP
A variable declaration includes the
type, the variable name, and optionally an initial value which can
be any Little expression:
.PP
.Vb 1
\&    int i = 3*2;
\&
\&    printf("i = %d\en", i);  // prints i = 6
.Ve
.PP
If an initial value is omitted, the variable starts out with the
undefined value \f(CW\*(C`undef\*(C'\fR.
.IP "Scalars" 4
.IX Item "Scalars"
A scalar represents a single value that is a string, integer, or
floating-point number.
Strings are wide char (unicode),
integers are arbitrarily large,
and floats are like C's double.
.Sp
Examples:
.Sp
.Vb 3
\&    string animal = "camel";
\&    int answer = 42;
\&    float pi = 3.14159;
.Ve
.Sp
When one of these types is expected, supplying another one usually is
an error, except that an int always can be used as a float.  You can
override this behavior with a type cast.
.Sp
Hex and octal integer constants are specified like this:
.Sp
.Vb 2
\&    int space = 0x20;
\&    int escape = 0o33;
.Ve
.Sp
Integer constants can be arbitrarily large; they are not limited
by the machine's word size.
.Sp
Strings have a special feature where they can be indexed like arrays,
to get a character or range of characters, or to change a character
(but you cannot change a range of characters):
.Sp
.Vb 1
\&    string s1, s2;
\&
\&    s1 = "hello";
\&    s2 = s1[1];     // s2 gets "e"
\&    s2 = s1[1..3];  // s2 gets "ell"
\&    s1[1] = "x";    // changes s1 to "hxllo"
\&    s1[END+1] = "there";    // changes s1 to "hxllothere"
.Ve
.Sp
The pre-defined identifier \f(CW\*(C`END\*(C'\fR is the index of the last character,
or is \-1 if the string is empty.  You always can write to one past the end
of a string to append to it, but writing beyond \s-1END+1\s0 is an error.
.Sp
You delete a character within a string by indexing the string and
setting it to "" (the empty string), or by using the \f(CW\*(C`undef()\*(C'\fR built-in:
.Sp
.Vb 2
\&    s[3] = "";    // deletes fourth character of s
\&    undef(s[3]);  // same thing
.Ve
.Sp
After the deletion any characters after the deleted character are shifted
left by one:
.Sp
.Vb 2
\&    s = "123X456";
\&    undef(s[3]);  // s is now "123456", the X is gone, the rest left shifted
.Ve
.IP "Undef" 4
.IX Item "Undef"
Sometimes you want to signify that a variable has no legal value, such
as when returning an error from a function.  Little has a read-only pre-defined
identifier called \f(CW\*(C`undef\*(C'\fR which you can assign to any variable.
.Sp
.Vb 2
\&    int_var = undef;
\&    array_var = undef;
.Ve
.Sp
This is different than the \f(CW\*(C`undef()\*(C'\fR built-in \fIfunction\fR which
deletes array, hash, or string elements.
.Sp
When used in comparisons, a variable that is undefined is never seen
as true, or as equal to anything defined, so you can easily check for
error conditions:
.Sp
.Vb 6
\&    unless (f = fopen(file, "r")) {
\&        die(file);
\&    }
\&    while (s = <f>) {
\&        printf("%s\en", s);
\&    }
.Ve
.Sp
You have to be a little careful because any numeric value (and poly)
can be false in a condition because it can have the value of zero:
.Sp
.Vb 1
\&    int i;
\&
\&    i = 0;
\&    if (i)              // false
\&
\&    i = 1;
\&    if (i)              // true.
\&
\&    i = undef;
\&    if (i)              // false
\&
\&    i = 0;
\&    if (defined(i))     // true
\&    if (i)              // false
.Ve
.Sp
Other than numeric types, you can skip the \fIdefined()\fR and just use
if (var).  That's true for arrays, structs, hashes, and \s-1FILE\s0 types.
.Sp
Little itself sometimes uses undef to tell you that no value is available.
One case is when you assign to an array element that is more than one
past the end of an array.  Little auto-extends the array and sets the
unassigned elements to undef.
.IP "Arrays" 4
.IX Item "Arrays"
An array holds a list of values, all of the same type:
.Sp
.Vb 2
\&    string animals[] = { "camel", "llama", "owl" };
\&    int numbers[] = { 23, 42, 69 };
.Ve
.Sp
You do not specify a size when declaring an array, because
arrays grow dynamically.
.Sp
Arrays are zero-indexed.  Here's how you get at elements in an array:
.Sp
.Vb 2
\&    puts(animals[0]);              // prints "camel"
\&    puts(animals[1]);              // prints "llama"
.Ve
.Sp
The pre-defined identifier \f(CW\*(C`END\*(C'\fR is the index of the last element
of an array, or is \-1 if the array is empty.
.Sp
.Vb 1
\&    puts(animals[END]);       // last element, prints "owl"
.Ve
.Sp
\&\s-1END\s0 is valid only inside of an array subscript (strings are a kind of
array so \s-1END\s0 works there).
.Sp
If you need the length of an array, use a built-in function:
.Sp
.Vb 1
\&    num_elems = length(animals);   // will get 3
.Ve
.Sp
If the array is empty, \fIlength()\fR returns 0.
.Sp
To get multiple values from an array, you use what's called an array
\&\f(CW\*(C`slice\*(C'\fR which is a sub-array of the array being sliced.
Slices are for reading values only; you cannot write to a slice.
.Sp
.Vb 2
\&    animals[0..1];            // gives { "camel", "llama" }
\&    animals[1..END];          // gives all except the first element
.Ve
.Sp
In this last example where \s-1END\s0 is used, you must be careful, because if
the array is empty, \s-1END\s0 will be \-1, and an array slice where the
second index is less than the first causes a run-time error.
.Sp
You can add and remove from an array with \f(CW\*(C`push\*(C'\fR and \f(CW\*(C`pop\*(C'\fR,
\&\f(CW\*(C`unshift\*(C'\fR and \f(CW\*(C`shift\*(C'\fR, and \f(CW\*(C`insert\*(C'\fR.
The \f(CW\*(C`push\*(C'\fR and \f(CW\*(C`pop\*(C'\fR functions add and remove from the end:
.Sp
.Vb 1
\&    string birds[], next;
\&
\&    push(&birds, "robin");
\&    push(&birds, "dove", "cardinal", "bluejay");
\&    next = pop(&birds);   // next gets "bluejay"
\&    // birds is now { "robin", "dove", "cardinal" }
.Ve
.Sp
The & means that birds is passed by reference, because it will
be changed.  This is discussed in more detail in the section on
functions.
.Sp
Another way to append:
.Sp
.Vb 1
\&    birds[END+1] = "towhee";
.Ve
.Sp
The \f(CW\*(C`unshift\*(C'\fR and \f(CW\*(C`shift\*(C'\fR functions are similar but they add
and remove from the beginning of the array.
.Sp
You can insert anywhere in an array with \f(CW\*(C`insert\*(C'\fR:
.Sp
.Vb 2
\&    insert(&birds, 2, "crow");  // insert crow before birds[2]
\&    insert(&birds, 3, "hawk", "eagle");
.Ve
.Sp
In these examples we inserted one or more single elements but
whereever you can put an element you also can splice in a list:
.Sp
.Vb 2
\&    string new_birds[] = { "chickadee", "turkey" };
\&    push(&birds, new_birds);  // appends chickadee and turkey
.Ve
.Sp
In this example the variable \f(CW\*(C`new_birds\*(C'\fR is not required;
an array constant could have been pushed instead:
.Sp
.Vb 1
\&    push(&birds, { "chickadee", "turkey" });
.Ve
.Sp
There is an ambiguity, resolved by the type of the first argument, as to
whether it is two strings being pushed as two new entries in the array, or if
it is a single item being pushed.  You have to know the type of the 
first argument to know which is which.
.Sp
You can remove from anywhere in an array with \f(CW\*(C`undef\*(C'\fR:
.Sp
.Vb 2
\&    string dev_team[] = { "larry", "curly", "mo" };
\&    undef(dev_team[0]);  // delete "larry" from dev_team
.Ve
.Sp
When you delete an element, all subsequent elements slide down
by one index.  Note that \fIundef()\fR works only on a variable; it
cannot remove an element from a function return value, for example.
.Sp
You also can directly assign to any array index even if the array
hasn't yet grown up to that index.  If you assign more than one past
the current end, the unassigned elements are assigned undef:
.Sp
.Vb 3
\&    string colors[] = { "blue, "red" };
\&    colors[3] = "green";   // colors[2] gets undef and
\&                           // colors[3] gets "green"
.Ve
.Sp
You can read from any non-negative array index as well.  You will simply
get undef if the element doesn't exist.  Reading from a negative index
causes a run-time error.
.Sp
An array can hold elements of any type, including other arrays.
Although Little does not have true multi-dimensional arrays, arrays of
arrays give you basically the same thing:
.Sp
.Vb 5
\&    int matrix[][] = {
\&        { 1, 2, 3 },
\&        { 4, 5, 6 },
\&        { 7, 8, 9 }
\&    };
.Ve
.Sp
When declaring an array, it is legal to put the brackets after the
type instead of the name.  This sometimes is useful for readability,
and is required in function prototypes that omit the parameter name.
.Sp
.Vb 2
\&    int[] mysort(int[]);        // prototype 
\&    int[] mysort(int vector[]) { ... }
.Ve
.Sp
An array in Little is implemented as a Tcl list under the covers.
.IP "Hashes" 4
.IX Item "Hashes"
A hash holds a set of key/value pairs:
.Sp
.Vb 1
\&    int grades{string} = { "Tom"=>85, "Rose"=>90 };
.Ve
.Sp
When you declare a hash, you specify both the key type (within the {})
and the value type.  The keys must be of scalar type but the values can
be of any type, allowing you to create hashes of arrays or other hashes.
.Sp
To get at a hash element, you index the hash with the key:
.Sp
.Vb 1
\&    grades{"Rose"};           // gives 90
.Ve
.Sp
If the given key does not exist in the hash, you get back undef.
Using an undefined key causes a run-time error.
.Sp
You get a list of all the keys in a hash with the \f(CW\*(C`keys()\*(C'\fR built-in,
which returns an array:
.Sp
.Vb 1
\&    string students[] = keys(grades);
.Ve
.Sp
Because hashes have no particular internal order, the order in which
the keys (\*(L"Tom\*(R" and \*(L"Rose\*(R") appear is undefined.  However, you can
obtain a sorted array of keys like this:
.Sp
.Vb 1
\&    string students[] = sort(keys(grades));
.Ve
.Sp
The \f(CW\*(C`length\*(C'\fR built-in works on hashes too and returns the number of
key/value pairs.
.Sp
You remove an element from a hash with \f(CW\*(C`undef\*(C'\fR:
.Sp
.Vb 1
\&    undef(grades{"Tom"});  // removes "Tom" from the hash
.Ve
.Sp
Note that this is different than assigning undef to a hash element,
which does not remove that element from the hash, it creates an
element with the value \f(CW\*(C`undef\*(C'\fR.
It is not an error to remove something that's not in the hash.  Note
that \fIundef()\fR works only on a variable; it cannot remove an element
from a function return value, for example.
.Sp
When declaring a hash, it is legal to put the braces after the
type instead of the name.  It comes in handy for function definitons,
here is is function that is returning an hash of integer grades indexed
by student name after adjusting them:
.Sp
.Vb 2
\&    int{string} adjust_grades(int{string});     // prototype
\&    int{string} adjust_grades(int grades{string}) { ... }
.Ve
.Sp
A hash in Little is implemented as a Tcl dict.
.IP "Structs" 4
.IX Item "Structs"
Little structs are much like structs in C.  They contain a fixed number
of named things of various types:
.Sp
.Vb 6
\&    struct my_struct {
\&        int    i;
\&        int    j;
\&        string s;
\&    };
\&    struct my_struct st = { 1, 2, "hello" };
.Ve
.Sp
You index a struct with the \*(L".\*(R" operator except when it is a
call-by-reference parameter and then you must use \*(L"\->\*(R":
.Sp
.Vb 7
\&    void foo(struct my_struct &byref) {
\&        puts(byref\->s);  // prints hello
\&    }
\&    puts(st.i);    // prints 1
\&    puts(st.j);    // prints 2
\&    puts(st.s);    // prints hello
\&    foo(&st);      // pass st by reference
.Ve
.Sp
It is an error to use \*(L".\*(R" when \*(L"\->\*(R" is required and vice-versa.  Be
careful to not put any whitespace around the \*(L".\*(R" or else you will get
the string concatenation operator and not struct-member selection (this
is a questionable overload of the \*(L".\*(R" operator but too useful to pass
up).
.Sp
Structs can be named like \f(CW\*(C`my_struct\*(C'\fR above or they can be anonymous:
.Sp
.Vb 4
\&    struct {
\&        int    i;
\&        int    j;
\&    } var1;
.Ve
.Sp
Struct names have their own namespace, so they will never clash with
function, variable, or type names.
.Sp
A struct in Little is implemented as a Tcl list.
.IP "Lists" 4
.IX Item "Lists"
In the examples above, we have been initializing arrays, hashes, and
structs by putting values inside of {}:
.Sp
.Vb 1
\&    string nums[] = { "one", "two", "three" };
.Ve
.Sp
In Little, the \f(CW\*(C`{}\*(C'\fR is an operator that creates a \f(CW\*(C`list\*(C'\fR and can be used
anywhere an expression is valid.  The array could instead be
initialized like this:
.Sp
.Vb 2
\&    string nums[];
\&    nums = { "one", "two", "three" };
.Ve
.Sp
We said before that you can assign a value to something only if it has
a compatible type.  Lists are special in that they can be compatible
with arrays, hashes, and structs.  A list where all the elements are
of the same type, say T, is compatible with an array of things of
type T.  The example above illustrates this.
.Sp
A list also is compatible with a struct if the list elements agree
in type and number with the struct.  The assignment of the variable
\&\f(CW\*(C`st\*(C'\fR above illustrates this.
.Sp
A list is compatible with a hash if it has a sequence of key/value
pairs and they are all compatible with the key/value types of
the hash:
.Sp
.Vb 1
\&    int myhash{string} = { "one"=>1, "two"=>2, "three"=>3 };
.Ve
.Sp
Lists are very useful at times because you can use them to build up
larger complex structures.  To concatenate two arrays, you could do
this:
.Sp
.Vb 1
\&    { (expand)array1, (expand)array2 };
.Ve
.Sp
The (expand) operator takes an array (or struct or list) and moves its
elements out a level as if they were between the { and } separated by
commas.  The section on manipulating complex data structures has more
details on the (expand) operator.
.Sp
A list in Little is implemented as a Tcl list.
.IP "Poly" 4
.IX Item "Poly"
Sometimes you don't want Little to do type checking.
In this case, you use the \f(CW\*(C`poly\*(C'\fR type, which is compatible with
any type.  Poly effectively disables type checking, allowing you
to use or assign values without regard to their types.  Obviously,
care must be taken when using poly.
.Sp
The \fB\-poly\fR option to Little causes all variables to be treated as if they
were of type poly, regardless of how they are declared.
.IP "Type Casts" 4
.IX Item "Type Casts"
Something of one type can be converted into something of another
type with a type cast like in C:
.Sp
.Vb 1
\&    string_var = (string)13;
.Ve
.Sp
If the thing being cast cannot be converted to the requested type, the
result of the cast is \f(CW\*(C`undef\*(C'\fR.
.IP "Typedefs" 4
.IX Item "Typedefs"
You can declare a type name to be a shorthand for another type, as
you would in C:
.Sp
.Vb 3
\&    typedef struct {
\&        int     x, y;
\&    } point;
.Ve
.Sp
And then use the shorthand as you would any other type name:
.Sp
.Vb 2
\&    point points[];
\&    points[] = { 1,1, 2,2, 3,3 };
.Ve
.Sp
You can typedef a function pointer too.  This declares compar_t
as type function that takes two ints and returns an int:
.Sp
.Vb 1
\&    typedef int compar_t(int a, int b);
.Ve
.Sp
Type names belong to their own namespace, so you can define a typedef
with the same name as a variable, function, or struct without
ambiguity (though it is poor practice to do so).
.SS "Name scoping"
.IX Subsection "Name scoping"
Variables must be declared before use, or a compile-time error
will result.  However, functions need not be declared before use
although it is good practice to do so.
.PP
Declarations at the top-level code exist at the \f(CW\*(C`global\*(C'\fR scope and
are visible across all scripts executed by a single run of Little.  You can
qualify a global declaration with \f(CW\*(C`private\*(C'\fR to restrict it to the
current file only; this is similar to a \f(CW\*(C`static\*(C'\fR in C, except that
private globals are not allowed to shadow public globals.  Names
declared in a function, or in a block within a function, are \f(CW\*(C`local\*(C'\fR
and are scoped to the block in which they are declared.
.PP
Functions and global variables share the same namespace, so a
variable and function cannot have identical names.  Struct tags
have their own namespace, and type names have theirs.
.PP
Inside a function, two locals cannot share the same name, even if they
are in parallel scopes.  This is different than C where this is
allowed. If a local shares the same name as a global,
the local is said to \f(CW\*(C`shadow\*(C'\fR the global.
Locals cannot shadow globals that have been previously declared.
.PP
Names declared inside of a class can be either local or global
depending on how they are qualified.
.SH "String interpolation"
.IX Header "String interpolation"
Expressions can be interpolated into double-quoted strings, which
means that within a string you can write an expression and at run-time
its value will be inserted.  For example, this interpolates two
variables:
.PP
.Vb 2
\&    int    a = 12;
\&    string b = "hello";
\&
\&    /* This will print "A is 12 and b is hello". */
\&
\&    printf("A is ${a} and b is ${b}\en");
.Ve
.PP
Everything inside the ${} is evaluated like any other Little expression, so
it is not limited to just variables:
.PP
.Vb 2
\&    printf("The time is ${\`date\`}\en");
\&    s = "The result is {some_function(a, b, c) / 100}";
.Ve
.SH "Here documents"
.IX Header "Here documents"
Sometimes you need to assign a multi-line string to a variable.
\&\f(CW\*(C`Here documents\*(C'\fR help with that:
.PP
.Vb 5
\&    string s = <<EOF
\&    This is the first line in s.
\&    This is the second.
\&    And the last.
\&    EOF;
.Ve
.PP
Everything in the line starting after the initial <<\s-1EOF\s0 delimiter and
before the final \s-1EOF\s0 delimiter gets put into the variable \f(CW\*(C`s\*(C'\fR.  You
can use any identifier you want as the delimiter, it doesn't have
to be \s-1EOF.
A\s0 semicolon after the \s-1EOF\s0 is optional.
.PP
The text inside the here document undergoes interpolation and escape
processing.
If you don't want that, put the initial delimiter inside of single
quotes:
.PP
.Vb 5
\&    string s = <<\*(AqEOF\*(Aq
\&    None of this text is interpolated.
\&    So this ${xyz} appears literally as \*(Aq${xyz}\*(Aq.
\&    And so does \e and \*(Aq and " and anything else.
\&    EOF;
.Ve
.PP
To help readability, you can indent your here document but have
the indenting white space ignored.
Put the initial delimiter on the next line and then
whatever whitespace you put before it gets ignored:
.PP
.Vb 6
\&    string s =
\&        <<EOF
\&        This is the first line in s and gets no leading white space.
\&         This line ends up with a single leading space.
\&          And this ends up with two.
\&        EOF;
.Ve
.PP
Exceptions to the indentation rule: 
a blank line is processed as if it is indented,
and the end delimiter can have any amount of leading white space
so that you can indent it more or less if you like.
.SH "Operators"
.IX Header "Operators"
.IP "Arithmetic" 4
.IX Item "Arithmetic"
.Vb 7
\&    +   addition
\&    ++  increment by 1 (integer only)
\&    \-   subtraction
\&    \-\-  decrement by 1 (integer only)
\&    *   multiplication
\&    /   division
\&    %   remainder
.Ve
.IP "Numeric and String comparison" 4
.IX Item "Numeric and String comparison"
.Vb 6
\&    ==  equality
\&    !=  inequality
\&    <   less than
\&    >   greater than
\&    <=  less than or equal
\&    >=  greater than or equal
.Ve
.IP "String comparison" 4
.IX Item "String comparison"
.Vb 2
\&    =~  regexp match or substitute
\&    !~  negated regexp match
.Ve
.IP "Comparison of composite types (array, hash, struct)" 4
.IX Item "Comparison of composite types (array, hash, struct)"
.Vb 1
\&    eq(a,b)
.Ve
.IP "Bit operations" 4
.IX Item "Bit operations"
.Vb 6
\&    &   bit and
\&    |   bit or
\&    ^   bit exclusive or
\&    ~   bit complement
\&    <<  left shift
\&    >>  right shift
.Ve
.IP "Boolean logic" 4
.IX Item "Boolean logic"
.Vb 3
\&    &&  and
\&    ||  or
\&    !   not
.Ve
.IP "Conditional" 4
.IX Item "Conditional"
.Vb 1
\&    ?:  ternary conditional (as in C)
.Ve
.IP "Indexing" 4
.IX Item "Indexing"
.Vb 5
\&    []  array index
\&    {}  hash index
\&    .   struct index (no whitespace around the dot)
\&    \->  struct index (call\-by\-reference parameters dereference)
\&    \->  class and instance variable access (object dereference)
.Ve
.IP "Miscellaneous" 4
.IX Item "Miscellaneous"
.Vb 4
\&    =   assignment
\&    ,   statement sequence
\&    .   string concatenation (must have whitespace around the dot)
\&    \`\`  command expansion
.Ve
.IP "Assignment" 4
.IX Item "Assignment"
.Vb 1
\&    +=, \-=, *=, /=, %=, &=, |=, ^=, <<=, >>=, .=
.Ve
.IP "Operator precedence (highest to lowest) and associativity" 4
.IX Item "Operator precedence (highest to lowest) and associativity"
.Vb 10
\&    \`\` (non associative)
\&    [] {} . (struct index) \-> ++ \-\- (left)
\&    unary + unary \- ! ~ & (right)
\&    * / % (left)
\&    + \- . (string concatenation) (left)
\&    << >> (left)
\&    < <= > >= (left)
\&    == != =~ !~ (left)
\&    & (left)
\&    ^ (left)
\&    | (left)
\&    && (left)
\&    || (left)
\&    ?: (right)
\&    = += \-= *= /= %= &= |= ^= <<= >>= .= (right)
\&    , (left)
.Ve
.SH "Control transfer statements"
.IX Header "Control transfer statements"
Little has most of the usual conditional and looping constructs.
.PP
For conditionals, numeric variables (including poly variables with
a number in them), evaluate to true or false based on their value.
If you want to know if a numeric variable is defined you have to
use the \f(CW\*(C`defined()\*(C'\fR builtin.
.PP
For all other variable types (arrays, hashes, structs, strings, etc),
the variable itself will yield true or false if it is / is not 
defined.
.PP
.Vb 5
\&    int undefined = undef;
\&    int zero = 0;
\&    int one = 1;
\&    string args[];
\&    string more[] = { "hi", "there", "mom" };
\&
\&    if (undefined)          // false (undef)
\&    if (zero)               // false (0 value)
\&    if (defined(zero))      // true (not undef)
\&    if (one)                // true (1 value)
\&    if (defined(one))       // true (set to some value)
\&    if (args)               // false, not initialized
\&    if (more)               // true, initialized
.Ve
.PP
See the list of operators in the next section for information on
comparison and logic operators, which are commonly used in conditional
statements.
.IP "if" 2
.IX Item "if"
The \f(CW\*(C`if\*(C'\fR statement comes in the traditional form:
.Sp
.Vb 7
\&    if ( condition ) {
\&        ...
\&    } else if ( other condition ) {
\&        ...
\&    } else {
\&        ...
\&    }
.Ve
.Sp
And there's a negated version of it (from Perl) provided as a more readable
version of \f(CW\*(C`if (!\f(CIcondition\f(CW)\*(C'\fR.
.Sp
.Vb 3
\&    unless ( condition ) {
\&        ...
\&    }
.Ve
.IP "while" 2
.IX Item "while"
.Vb 3
\&    while ( condition ) {
\&        ...
\&    }
\&
\&    do {
\&        ...
\&    } while ( condition )
.Ve
.IP "for" 2
.IX Item "for"
.Vb 3
\&    for (i = 0; i < max; ++i) {
\&        ...
\&    }
.Ve
.IP "foreach" 2
.IX Item "foreach"
The \f(CW\*(C`foreach\*(C'\fR statement lets you iterate through the elements of an
array:
.Sp
.Vb 2
\&    string element;
\&    string myarray[];
\&
\&    foreach (element in myarray) {
\&        printf("This element is %s\en", element);
\&    }
.Ve
.Sp
\&... or of a hash:
.Sp
.Vb 3
\&    string key;
\&    int value;
\&    int myhash{string};
\&
\&    foreach (key=>value in myhash) {
\&        printf("Key %s has value %d\en", key, value);
\&    }
.Ve
.Sp
\&... or of a string:
.Sp
.Vb 1
\&    string char;
\&
\&    foreach (char in mystring) {
\&        printf("This char is %s\en", char);
\&    }
.Ve
.Sp
\&... or through the lines in a string:
.Sp
.Vb 3
\&    int i = 0;
\&    string s;
\&    string lines = "a\enbb\enccc\endddd\en";
\&
\&    # (questionable) alias for foreach (s in split(/\en/, lines))
\&    foreach (s in <lines>) {
\&        puts("line #${++i}: ${s}");
\&    }
.Ve
.Sp
Inside the loop, the index variable(s) (\f(CW\*(C`element\*(C'\fR, \f(CW\*(C`key\*(C'\fR, \f(CW\*(C`val\*(C'\fR, and
\&\f(CW\*(C`char\*(C'\fR above) get \fIcopies\fR of the iterated elements, so
if you assign to them, the thing you're iterating over does not change.
.Sp
If you want to stride through more than one array element, character,
or line in each iteration, just use a list of value variables instead of one:
.Sp
.Vb 3
\&    foreach (e1,e2,e3 in myarray) {
\&        printf("Next three are %s:%s:%s\en", e1, e2, e3);
\&    }
.Ve
.Sp
If there isn't a multiple of three things to iterate through, the
stragglers get undef on the last iteration.  Strides
work only for arrays and strings, not hashes.
.Sp
After completing the loop and falling through, all loop counters
become undefined (they get the \f(CW\*(C`undef\*(C'\fR value).  If the loop
is prematurely ended with a \f(CW\*(C`break\*(C'\fR or by jumping out of the
loop with a \f(CW\*(C`goto\*(C'\fR, the loop counters keep their values.
.IP "switch" 2
.IX Item "switch"
The \f(CW\*(C`switch\*(C'\fR statement is like C's except that regular expressions
and/or strings can be used as case expressions:
.Sp
.Vb 10
\&    switch (string_var) {
\&        case "true":
\&        case "false":
\&            puts("boolean (sort of)");
\&            break;
\&        case /[0\-9]+/:
\&            puts("numeric");
\&            break;
\&        case /[a\-zA\-Z][0\-9a\-zA\-Z]*/:
\&            puts("alphanumeric");
\&            break;
\&        default:
\&            puts("neither");
\&            break;
\&    }
.Ve
.Sp
The default case is optional.  The expression being switched on
must be of type integer, string or poly.
.Sp
In addition to checking the value of the switch expression,
you can test whether it is undefined.
This is useful when switching on a function return value
which could be \f(CW\*(C`undef\*(C'\fR to signal an error condition.
.Sp
.Vb 11
\&    switch (myfunc(arg)) {
\&        case /OK/:
\&            puts("all is A\-OK");
\&            break;
\&        case undef:
\&            puts("error");
\&            break;
\&        default:
\&            puts("unknown return value");
\&            break;
\&    }
.Ve
.Sp
Regular expressions have an alternative syntax (borrowed from Perl)
that is used when the expression may contain \*(L"/\*(R".
In switch statements that syntax is somewhat restricted
because of the parsing problems you can imagine below:
.Sp
.Vb 11
\&    switch (str) {
\&        case m|x*y|:    // "|" and most other punctuation as the delim
\&                        // are OK,
\&                        // except "(" and ":" \-\- error
\&                        // and any alphabetic character \-\- error
\&            break;
\&        case m:         // is the variable m (not a regexp) \-\- ok
\&            break;
\&        case mvar:      // and variables starting with "m" \-\- ok
\&            break;
\&    }
.Ve
.IP "break and continue" 2
.IX Item "break and continue"
Little has \f(CW\*(C`break\*(C'\fR and \f(CW\*(C`continue\*(C'\fR statements that behave like C's.
They work in all Little loops including \f(CW\*(C`foreach\*(C'\fR loops, and \f(CW\*(C`break\*(C'\fR works
in \f(CW\*(C`switch\*(C'\fR case bodies.
.IP "goto" 2
.IX Item "goto"
The \f(CW\*(C`goto\*(C'\fR statement unconditionally transfers control to a label in
the same function, or to a label at the global scope if the goto is at
the global scope.  You cannot use a goto to transfer in to or out of
a function.  Labels have their own namespace so they will not clash
with variable, function, or type names.
.Sp
.Vb 4
\&    /* A goto at the global scope. */
\&    goto L1;
\&    puts("this is not executed");
\&L1: puts("but this is");
\&
\&    void foo()
\&    {
\&        goto L2;
\&        puts("this is not executed");
\&L2:     puts("but this is");
\&    }
.Ve
.Sp
Some caveats: do not jump into a foreach loop or a run-time error may
result due to bypassing the loop set-up.  Do not bypass a variable
declaration or else the variable will be inaccessible.
.SH "Functions"
.IX Header "Functions"
Little's functions are much like functions in C.  Like variable names,
function names \fBcannot\fR begin with an underscore (_).
.PP
Each function must be declared with a return type and a
formal-parameter list:
.PP
.Vb 4
\&    int sum(int a, int b)
\&    {
\&        return (a + b);
\&    }
.Ve
.PP
\&\f(CW\*(C`void\*(C'\fR is a legal return type for a function that returns no value.
Functions cannot be nested.
.PP
Function prototypes are allowed, where all but the function body is
declared.  In a prototype, you can omit any parameter names or use
\&\f(CW\*(C`void\*(C'\fR for an empty parameter list:
.PP
.Vb 3
\&    void no_op1(void);
\&    void no_op2();
\&    int sum(int, int);
.Ve
.PP
Unlike Perl, when calling a function you must use parentheses around
the arguments:
.PP
.Vb 1
\&    sum(a, b);
.Ve
.PP
Little does a special kind of call called a \f(CW\*(C`pattern function\*(C'\fR call
when the function name is capitalized and contains an underscore;
these are useful for calling Tcl commands and are described later
in the section \*(L"Calling Tcl from Little\*(R".
Normal function names therefore should not be capitalized
and contain an underscore.
.PP
Parameters are passed by value by default.  To pass by reference,
you use a \f(CW\*(C`&\*(C'\fR in the declaration and in the function call:
.PP
.Vb 4
\&    void inc(int &arg)
\&    {
\&        ++arg;
\&    }
\&
\&    inc(&x);  // inc() can change x
.Ve
.PP
The \f(CW\*(C`&\*(C'\fR only tells Little to pass by reference.  It is not a pointer (no
pointer arithmetic), it is a reference.
You use a reference to give the called function the ability to change
the caller's variable.
.PP
Only variables can be passed by reference, not elements of arrays,
hashes, or structs.  This is one significant difference from C.
Passing an array, hash, or struct element with \f(CW\*(C`&\*(C'\fR uses \f(CW\*(C`copy in/out\*(C'\fR,
not a true reference.  The element value is copied
into a temp variable and the temp is passed by reference.  Then when
the function returns, any changes to the temp are copied back into the
array, hash, or struct element.  In most cases this behaves like
call-by-reference and you don't need to worry about it.
But if you access the passed element during the function call,
by referencing it directly instead of through the formal parameter,
then you must be careful:
.PP
.Vb 11
\&    string array[] = { "one", "two" };
\&    void fn(string &var, string val)
\&    {
\&        var = val;
\&        array[0] = "this gets overwritten by the copy\-out";
\&    }
\&    void main()
\&    {
\&        fn(&array[0], "new");
\&        puts(array[0]);  // will print "new"
\&    }
.Ve
.PP
Instead of passing a reference, you can pass \f(CW\*(C`undef\*(C'\fR like you would a
\&\s-1NULL\s0 pointer in C.
You test for this with the \f(CW\*(C`defined()\*(C'\fR operator:
.PP
.Vb 4
\&    void inc(int &arg)
\&    {
\&        if (defined(&arg)) ++arg;
\&    }
\&
\&    inc(undef);   // does nothing
\&    inc(&x);      // increments x
.Ve
.PP
In the example above, you might question why it is \f(CW\*(C`defined(&arg)\*(C'\fR
instead of \f(CW\*(C`defined(arg)\*(C'\fR.  If you think of it in terms of C,
the \f(CW&arg\fR is like looking at a pointer, you are seeing if it is 
non-null, the \f(CW\*(C`arg++\*(C'\fR is like \f(CW\*(C`*p += 1\*(C'\fR.
.PP
If you pass \f(CW\*(C`undef\*(C'\fR as a reference and then attempt to access
the parameter, a run-time error results similar to derefencing
a \s-1NULL\s0 pointer in C.
.PP
When accessing a struct argument inside a function, if the struct was
passed by reference, the \*(L"\->\*(R" operator must be used instead of \*(L".\*(R".
This makes it clear to the reader that the struct variable is passed
by reference; it is intended to allude to a C pointer even though Little
does not have general-purpose pointers.
.SS "Variable arguments to functions"
.IX Subsection "Variable arguments to functions"
Functions can take a variable number of arguments, like printf does.
In the function declaration, you use the qualifier \*(L"...\*(R" in front
of the last formal parameter name and omit its type:
.PP
.Vb 7
\&    void dump(...args)
\&    {
\&        string s;
\&        foreach (s in args) puts(s);
\&    }
\&    dump("just one");
\&    dump("but two", "or three", "or more is OK");
.Ve
.PP
Inside the function, \f(CW\*(C`args\*(C'\fR has type array of poly, allowing any
number of parameters of any type to be passed.
.SS "The \fImain()\fP function"
.IX Subsection "The main() function"
If \fImain()\fR is present, it is called after all of the top-level statements
have executed.  The \fImain()\fR function may be defined in any of the following
ways:
.PP
.Vb 3
\&   void|int main(void) {}
\&   void|int main(string argv[]) {}
\&   void|int main(int argc, string argv[], string env{string}) {}
.Ve
.PP
The \f(CW\*(C`argv\*(C'\fR array is populated from the script name and any arguments
that appear after the name on the Little command line.
In this example, argc is 4 and argv[] contains \*(L"script.l\*(R", \*(L"arg1\*(R",
\&\*(L"arg2\*(R", and \*(L"arg3\*(R":
.PP
.Vb 1
\&   L script.l arg1 arg2 arg3
.Ve
.PP
The \f(CW\*(C`env\*(C'\fR hash is populated with the environment variables present
when Little is invoked.  Although you can change this hash, writes to it
are not reflected back into the environment.  To do that use the
\&\f(CW\*(C`putenv\*(C'\fR library function.
.PP
Only a \f(CW\*(C`main\*(C'\fR written in Little is automatically called.
You can write a \f(CW\*(C`main\*(C'\fR in Tcl but Little will not call it automatically.
.PP
If \f(CW\*(C`main\*(C'\fR is declared to have return type \f(CW\*(C`int\*(C'\fR then any value returned
will be the exit value.
.SS "Function pointers"
.IX Subsection "Function pointers"
Function pointers are supported, but only as arguments \*(-- you cannot
otherwise assign a function pointer to a variable.  It is common to
first typedef the function-pointer type; here is one for a function
that compares two strings:
.PP
.Vb 1
\&    typedef int str_compar_t(string a, string b);
.Ve
.PP
You can then pass such a compare function as follows:
.PP
.Vb 1
\&    string    a[];
\&
\&    bubble_sort(a, &unary_compar);
.Ve
.PP
Where the sort function looks like this:
.PP
.Vb 8
\&    string[] bubble_sort(string a[], str_compar_t &compar)
\&    {
\&        do {
\&            ...
\&            if (compar(a[i], a[i+1] > 0) { ... }
\&            ...
\&        } ...
\&    }
.Ve
.PP
And the compare function looks like this:
.PP
.Vb 4
\&    int unary_compar(string a, string b)
\&    {
\&        int     al = length(a);
\&        int     bl = length(b);
\&
\&        if (al < bl) {
\&                return \-1;
\&        } else if (al > bl) {
\&                return 1;
\&        } else {
\&                return 0;
\&        }
\&    }
.Ve
.SH "Regular expressions"
.IX Header "Regular expressions"
Little's regular expression support is based on the \s-1PCRE \s0(Perl Compatible
Regular Expressions) library <http://www.pcre.org>.  The basics are
documented here but for more extensive documentation please see
<http://www.pcre.org/pcre.txt>.
.IP "Simple matching" 4
.IX Item "Simple matching"
.Vb 2
\&    if (s =~ /foo/) { ... }  // true if s contains "foo"
\&    if (s !~ /foo/) { ... }  // false if s contains "foo"
.Ve
.Sp
The \f(CW\*(C`//\*(C'\fR matching operator must be used in conjunction with \f(CW\*(C`=~\*(C'\fR and
\&\f(CW\*(C`!~\*(C'\fR to tell Little what variable to look at.
.Sp
If your regular expression contains forward slashes, you must
escape them with a backslash, or you can use an alternate
syntax where almost any punctuation becomes the delimiter:
.Sp
.Vb 3
\&    if (s =~ m|/path/to/foo|) { ... }
\&    if (s =~ m#/path/to/foo#) { ... }
\&    if (s =~ m{/path/to/foo}) { ... }
.Ve
.Sp
In the last case, note that the end delimiter } is different
than the start delimiter { and you must escape all
uses of either delimiter inside the regular expression.
.IP "Simple substitution" 4
.IX Item "Simple substitution"
.Vb 4
\&    x =~ s/foo/bar/;         // replaces first foo with bar in x
\&    x =~ s/foo/bar/g;        // replaces all instances of foo
\&                             // with bar in x
\&    x =~ s/foo/bar/i;        // does a case\-insensitive search
.Ve
.Sp
This form also has several alternate syntaxes:
.Sp
.Vb 3
\&    x =~ s|/bin/root|~root|;
\&    x =~ s{foo}{bar};
\&    x =~ s{foo}/bar/;
.Ve
.IP "More complex regular expressions" 4
.IX Item "More complex regular expressions"
.Vb 11
\&    .                   a single character
\&    \es                  a whitespace character
\&                        (space, tab, newline, ...)
\&    \eS                  non\-whitespace character
\&    \ed                  a digit (0\-9)
\&    \eD                  a non\-digit
\&    \ew                  a word character (a\-z, A\-Z, 0\-9, _)
\&    \eW                  a non\-word character
\&    [aeiou]             matches a single character in the given set
\&    [^aeiou]            matches a single character not in given set
\&    (foo|bar|baz)       matches any of the alternatives specified
\&
\&    ^                   start of string
\&    $                   end of string
.Ve
.Sp
Quantifiers can be used to specify how many of the previous thing you
want to match on, where \*(L"thing\*(R" means either a literal character, one
of the meta characters listed above, or a group of characters or
meta characters in parentheses.
.Sp
.Vb 6
\&    *                   zero or more of the previous thing
\&    +                   one or more of the previous thing
\&    ?                   zero or one of the previous thing
\&    {3}                 matches exactly 3 of the previous thing
\&    {3,6}               matches between 3 and 6 of the previous thing
\&    {3,}                matches 3 or more of the previous thing
.Ve
.Sp
Some brief examples:
.Sp
.Vb 6
\&    /^\ed+/              string starts with one or more digits
\&    /^$/                nothing in the string (length == 0)
\&    /(\ed\es){3}/         a three digits, each followed by a whitespace
\&                        character (eg "3 4 5 ")
\&    /(a.)+/             matches a string in which every odd\-numbered
\&                        letter is "a" (eg "abacadaf")
\&
\&    // This loop reads from stdin, and prints non\-blank lines.
\&    string buf;
\&    while (buf = <stdin>) {
\&        unless (buf =~ /^$/) puts(buf);
\&    }
.Ve
.IP "Unicode" 4
.IX Item "Unicode"
Both regular expressions and the strings they are matched against
can contain unicode characters or binary data.
This example looks for a null byte in a string:
.Sp
.Vb 1
\&    if (s =~ /\e0/) puts("has a null");
.Ve
.IP "Parentheses for capturing" 4
.IX Item "Parentheses for capturing"
As well as grouping, parentheses serve a second purpose.  They can be
used to capture the results of parts of the regexp match for later use.
The results end up in \f(CW$1\fR, \f(CW$2\fR and so on, and these capture
variables are available in the substitution part of the operator
as well as afterward.
You can use up to nine captures ($1 \- \f(CW$9\fR).
.Sp
.Vb 5
\&    // Break an e\-mail address into parts.
\&    if (email =~ /([^@]+)@(.+)/) {
\&        printf("Username is %s\en", $1);
\&        printf("Hostname is %s\en", $2);
\&    }
\&
\&    // Use $1,$2 in the substitution to swap two words.
\&    str =~ s/(\ew+) (\ew+)/$2 $1/;
.Ve
.Sp
Capturing has a limitation.  If you have more than one regexp with
captures in an expression, the last one evaluated sets \f(CW$1\fR, \f(CW$2\fR,
etc.
.Sp
.Vb 5
\&    // This loses email1\*(Aqs captures.
\&    if ((email1 =~ /([^@]+)@(.+)/) && (email2 =~ /([^@]+)@(.+)/)) {
\&        printf("Username is %s\en", $1);
\&        printf("Hostname is %s\en", $2);
\&    }
.Ve
.Sp
In situations like this, care must be taken because the evaluation
order of sub-expressions generally is undefined.  But this example is
an exception because the && operator always evaluates its operands in
order.
.SH "Includes"
.IX Header "Includes"
Little has an \f(CW\*(C`#include\*(C'\fR statement like the one in the C pre-processor.
A #include can appear anywhere a statement can appear as long as it begins
in the first column and is contained entirely on one line:
.PP
.Vb 6
\&    #include <types.l>
\&    #include "myglobals.l"
\&    void main()
\&    {
\&        ...
\&    }
.Ve
.PP
Unless given an absolute path, when the file name is in angle brackets
(like <types.l>), Little searches these paths, where \s-1BIN\s0 is where the
running tclsh exists:
.PP
.Vb 3
\&    $BIN/include
\&    /usr/local/include/L
\&    /usr/include/L
.Ve
.PP
When the file name is in quotes (like \*(L"myglobals.l\*(R"), Little searches only
the directory containing the script that did the #include.
.PP
Little also remembers which files have been included and will not include a file
more than once, allowing you to have #include files that include each
other.
.SH "Classes"
.IX Header "Classes"
Little has a \f(CW\*(C`class\*(C'\fR abstraction for encapsulating data and
functions that operate on that data.  Little classes are simpler than
full-blown object-oriented programming (there is no inheritance), but
they get you most of the way there.
.PP
You declare a class like this:
.PP
.Vb 4
\&    class myclass
\&    {
\&        ....
\&    }
.Ve
.PP
The name \f(CW\*(C`myclass\*(C'\fR becomes a global type name, allowing you to
declare an \f(CW\*(C`object\*(C'\fR of \f(CW\*(C`myclass\*(C'\fR:
.PP
.Vb 1
\&    myclass obj;
.Ve
.PP
You can declare both variables and functions inside the class.  These
all must be declared inside one class declaration at the global scope.
You cannot have one class declaration that has some of the
declarations and another with the rest, and you cannot nest classes
inside of functions or other classes.
.PP
Inside the class, you can have \f(CW\*(C`class variables\*(C'\fR and
\&\f(CW\*(C`instance variables\*(C'\fR.  Class variables are associated with the class
and not the individual objects that you allocate, so there is only one
copy of each.  Instance variables get attached to each object.
.PP
.Vb 5
\&    class myclass
\&    {
\&        /* Class variables. */
\&        public string pub_var;
\&        private int num = 0;
\&
\&        /* Instance variables. */
\&        instance {
\&            public string inst_var;
\&            private int n;
\&        }
\&        ...
\&    }
.Ve
.PP
All declarations (except the constructors and destructors) must be
qualified with either \f(CW\*(C`public\*(C'\fR or \f(CW\*(C`private\*(C'\fR to say whether the name
is visible at the global scope or only inside the class.
.PP
A class can have one or more constructors and destructors but they are optional.
Inside a constructor, the variable \f(CW\*(C`self\*(C'\fR is automatically declared
as the object being constructed.  A constructor should return
\&\f(CW\*(C`self\*(C'\fR, although it also could return \f(CW\*(C`undef\*(C'\fR to signal an error.
A destructor must be declared with \f(CW\*(C`self\*(C'\fR as the first parameter.
.PP
.Vb 6
\&    constructor myclass_new()
\&    {
\&        n = num++;
\&        return (self);
\&    }
\&    destructor myclass_delete(myclass self) {}
.Ve
.PP
If omitted, Little creates a default constructor or destructor named
\&\f(CW\*(C`classname_new\*(C'\fR and \f(CW\*(C`classname_delete\*(C'\fR.  Although not shown in this
example, you can declare them with any number of parameters, just like
regular functions.
.PP
A \f(CW\*(C`public\*(C'\fR class member function is visible at the global scope, so
its name must not clash with any other global function or variable.  A
private member function is local to the class.
.PP
The first parameter to each public function must be \f(CW\*(C`self\*(C'\fR, the
object being operated on.  Private functions do not explicitly include
\&\f(CW\*(C`self\*(C'\fR in the parameter list because it is implicitly passed by the
compiler.
.PP
.Vb 9
\&    private void bump_num()
\&    {
\&        ++n;
\&    }
\&    public int myclass_getnum(myclass self)
\&    {
\&        bump_num();
\&        return (n);
\&    }
.Ve
.PP
To create an object, you must call a constructor, because just
declaring the variable does not allocate anything:
.PP
.Vb 1
\&    myclass obj;
\&
\&    obj = myclass_new();
.Ve
.PP
To operate on an object, you call one of its public member functions,
passing the object as the first argument:
.PP
.Vb 1
\&    int n = myclass_getnum(obj);
.Ve
.PP
Little allows you to directly access public class and instance variables
from outside the class.  To get a class variable, you dereference the
class name (you must use \->):
.PP
.Vb 1
\&    string s = myclass\->pub_var;
.Ve
.PP
To get a public instance variable, you dereference the object whose
data you want to access:
.PP
.Vb 1
\&    string s = obj\->inst_var;
.Ve
.PP
Once you free an object
.PP
.Vb 1
\&    myclass_delete(obj);
.Ve
.PP
you must be careful to not use \f(CW\*(C`obj\*(C'\fR again unless you assign a
new object to it, or else a run-time error will result.
.SH "Working with Tcl/TK"
.IX Header "Working with Tcl/TK"
Little is built on top of Tcl: Little functions are compiled down to Tcl procs,
Little local variables are just Tcl variables local to the proc, and Little global
variables are Tcl globals.
Although Little is designed to hide its Tcl underpinnings, sometimes it is
useful for Little and Tcl to cooperate.
.SS "Mixing Little and Tcl Code"
.IX Subsection "Mixing Little and Tcl Code"
When you invoke Little with a script whose name ends in \f(CW\*(C`.l\*(C'\fR, the script
must contain only Little code.
If you run a \f(CW\*(C`.tcl\*(C'\fR script, you can mix Little and Tcl:
.PP
.Vb 5
\&    puts "This is Tcl code"
\&    #lang L
\&    printf("This is Little code\en");
\&    #lang tcl
\&    puts "Back to Tcl code"
.Ve
.PP
You also can run Little code from within Tcl by passing the Little code to the
Tcl command named \f(CW\*(C`L\*(C'\fR:
.PP
.Vb 2
\&    puts "Tcl code again"
\&    L { printf("Called from the Little Tcl command.\en"); }
.Ve
.SS "Calling Tcl from Little"
.IX Subsection "Calling Tcl from Little"
You call a Tcl proc from Little like you would a Little function:
.PP
.Vb 2
\&    string s = "hello world";
\&    puts(s);
.Ve
.PP
In this example, \f(CW\*(C`puts\*(C'\fR is the Tcl command that outputs its argument
to the \f(CW\*(C`stdout\*(C'\fR channel appending a trailing newline.
.PP
If you want argument type checking, you can provide a prototype for the Tcl
functions you call.  Otherwise, no type checking is performed.
.PP
In Tcl, options usually are passed as strings like \*(L"\-option1\*(R" or \*(L"\-option2\*(R".
Little has a feature to pass these options more pleasantly:
.PP
.Vb 2
\&    func(option1:);            // passes "\-option1"
\&    func(option2: value, arg); // passes "\-option2", value, arg
.Ve
.PP
Without this, you would have to say:
.PP
.Vb 2
\&    func("\-option1");
\&    func("\-option2", value, arg);
.Ve
.PP
A similar feature is for passing sub-commands to Tcl commands:
.PP
.Vb 2
\&    String_length("xyzzy");   // like Tcl\*(Aqs [string length xyzzy]
\&    String_isSpace(s);        // like Tcl\*(Aqs [string is space $s]
.Ve
.PP
Whenever the function name is capitalized and contains an underscore,
the sequence of capitalized names after the underscore are converted
to (lower case) arguments (although capitalizing the
first name after the underscore is optional).
This is called a \f(CW\*(C`pattern function\*(C'\fR call.
.PP
.Vb 1
\&    x = Something_firstSecondThird(a, b)
.Ve
.PP
is like this in Tcl:
.PP
.Vb 1
\&    set x [something first second third $a $b]
.Ve
.PP
A pattern-function call often is used to call a Tcl proc, but you
can call a Little function just as easily, and Little has a special case
when the function is named like \f(CW\*(C`Myfunc_*\*(C'\fR:
.PP
.Vb 3
\&    void Myfunc_*(...args)
\&    {
\&        poly p;
\&
\&        printf("Myfunc_%s called with:\en", $1);
\&        foreach (p in args) printf("%s\en", p);
\&    }
\&    void main()
\&    {
\&        Myfunc_cmd1(1);
\&        Myfunc_cmd2(3,4,5);
\&    }
.Ve
.PP
If \f(CW\*(C`Myfunc_*\*(C'\fR is declared, then any call like \f(CW\*(C`Myfunc_x\*(C'\fR becomes a
call to \f(CW\*(C`Myfunc_*\*(C'\fR where the string \f(CW\*(C`x\*(C'\fR is put into the local
variable \f(CW$1\fR inside \f(CW\*(C`Myfunc_*\*(C'\fR.  The remaining parameters are
handled normally.
This gives you a way to handle a collection of sub-commands without
having to declare each as a separate Little function.
Note that this use of \f(CW$1\fR clashes with regular expression captures
(described later), so if you use both, you should save off \f(CW$1\fR
before using any such regular expressions.
.PP
Note: we are going to change this to not conflict with regular expressions.
.PP
If you need to execute arbitrary Tcl code rather than just call a proc,
you pass it to Tcl's \f(CW\*(C`eval\*(C'\fR command:
.PP
.Vb 1
\&    eval("puts {you guessed it, Tcl code again}");
.Ve
.SS "Calling Little from Tcl"
.IX Subsection "Calling Little from Tcl"
Little functions are easily called from Tcl, because a Little function
\&\f(CW\*(C`foo\*(C'\fR compiles down to a Tcl proc named \f(CW\*(C`foo\*(C'\fR in the global
namespace.
Let's say this is run from a script named \f(CW\*(C`script.tcl\*(C'\fR:
.PP
.Vb 11
\&    #lang L
\&    int avg(...args)
\&    {
\&        int i, sum=0;
\&        unless (length(args)) return (0);
\&        foreach (i in args) sum += i;
\&        return (sum/length(args));
\&    }
\&    #lang tcl
\&    set x [avg 4 5 6]
\&    puts "The average is $x"
.Ve
.PP
The Little code defines a proc named \f(CW\*(C`avg\*(C'\fR which the Tcl code then calls.
.PP
An exception is that \f(CW\*(C`private\*(C'\fR Little functions are not callable from Tcl.
.SS "Variables"
.IX Subsection "Variables"
Because Little variables are just Tcl variables, you can access Little variables
from Tcl code.  Here is an example from the Little library:
.PP
.Vb 3
\&    int size(string path)
\&    {
\&        int sz;
\&
\&        if (catch("set sz [file size $path]")) {
\&            return (\-1);
\&        } else {
\&            return (sz);
\&        }
\&    }
.Ve
.PP
In this Tcl code, \f(CW$path\fR refers to the Little formal parameter \f(CW\*(C`path\*(C'\fR,
and the Little local \f(CW\*(C`sz\*(C'\fR is set to the file size.  This example also
illustrates how you can use Tcl's exception-handling facility
to catch an exception raised within some Tcl code.
.PP
An exception is that private Little global names are mangled (to
make them unique per-file).
You can pass the mangled name to Tcl code with the \f(CW\*(C`&\*(C'\fR operator.
Here we are passing the name of the private function \f(CW\*(C`mycallback\*(C'\fR to
register a Tcl fileevent \*(L"readable\*(R" handler:
.PP
.Vb 1
\&    private void mycallback(FILE f) { ... }
\&
\&    fileevent(f, "readable", {&mycallback, f});
.Ve
.SS "Complex variables"
.IX Subsection "Complex variables"
Passing scalar variables works because they have the same representation
in Little and in Tcl.
.PP
Passing complex variables is trickier and is not supported, but if you
want to try here is what you need to know.  This is subject to change.
An Little array is a Tcl list.
An Little struct is a Tcl list with the first struct member as the first
list element and so on.
An Little hash table is a Tcl dict.
If a Little variable is deeply nested, so is the Tcl variable.
.PP
So long as you understand that and do the appropriate thing in both
languages, passing complex variables usually is possible.
.SS "Namespaces"
.IX Subsection "Namespaces"
You can access Tcl procs and variables in namespaces other than
the global namespace by qualifying the name:
.PP
.Vb 1
\&    extern string ::mynamespace::myvar;
\&
\&    /* Print a bytecode disassembly of the proc "foo". */
\&    puts(::tcl::unsupported::disassemble("proc", "foo"));
\&
\&    /* Print a variable in another namespace. */
\&    puts(::mynamespace::myvar);
.Ve
.SS "Calling Tk"
.IX Subsection "Calling Tk"
To help call Tk widgets, Little has a \f(CW\*(C`widget\*(C'\fR type that is used with the
pattern function calls described above.  A widget value behaves like
a string except in a pattern function call where it is the name
of the widget to call:
.PP
.Vb 2
\&    widget w = Text_new();
\&    Text_insert(w, "end", "hi!");   // like Tk\*(Aqs $w insert end hi!
.Ve
.PP
Another feature is useful for calling Tk widgets that take the \fIname\fR
of a variable whose value is updated when the user changes a widget
field.  You can use a Little variable like this:
.PP
.Vb 2
\&    string msg;
\&    ttk::label(".foo", textvariable: &msg);
.Ve
.PP
The ampersand (&) in front of \f(CW\*(C`msg\*(C'\fR alludes to a C pointer but it
really passes just the name of the variable.  Little does this when the
option name ends in \*(L"variable\*(R", as \*(L"textvariable\*(R" does in the example
above (yes, this is a hack).
.SS "Learning more about Tcl/Tk"
.IX Subsection "Learning more about Tcl/Tk"
The Little language distribution includes the Tcl and Tk repositories.
Each of those has a \f(CW\*(C`doc/\*(C'\fR subdirectory with files starting with 
upper case and lower case.  Ignore the upper case files ending in .3, those are
internal C \s-1API\s0 documentation.  The lower case files are Tcl / Tk 
exposed APIs.  They are all \f(CW\*(C`nroff \-man\*(C'\fR markup, to view
.PP
.Vb 1
\&    $ nroff \-man file.n | less
.Ve
.PP
For books we like these:
.PP
.Vb 2
\&    Tcl and the Tk Toolkit 2nd Edition
\&    Effective Tcl/Tk Programming: Writing Better Programs with Tcl and Tk
.Ve
.SH "Manipulating complex structures"
.IX Header "Manipulating complex structures"
Little has built-in operators for turning complex data structures into
something else: (expand), and (tcl).
.PP
(expand) takes an array of things and pushes them all onto the
run-time stack to call a function that expects such a list.
It is identical to Tcl's {*}:
.PP
.Vb 1
\&    void foo(string a, string b, string c);
\&
\&    string v[] = { "one", "two", "three" };
\&
\&    foo((expand)v);     // passes three string arguments to foo
.Ve
.PP
It expands only one level, so if the array contains three hashes
instead of three strings, (expand)v passes three hashes to foo.
(expand) works with structs too.
.PP
If you have this structure:
.PP
.Vb 7
\&    struct {
\&        int   i[];
\&        int   h{string};
\&    } foo = {
\&        { 0, 1, 2, 3, },
\&        { "big" => 100, "medium" => 50, "small" => 10 }
\&    };
.Ve
.PP
And you use (expand) when passing these as arguments:
.PP
.Vb 1
\&    func((expand)foo);
.Ve
.PP
you need a function definition like this:
.PP
.Vb 3
\&    void func(int nums[], int sizes{string})
\&    {
\&    }
.Ve
.PP
There is no way to recursively expand at this time.
.PP
(tcl) is used to pass a single string to a Tcl proc for processing.
It puts in the Tcl quotes.  So
.PP
.Vb 1
\&    (tcl)foo
.Ve
.PP
is
.PP
.Vb 1
\&    0 1 2 3 { big 100 medium 50 small 10 }
.Ve
.PP
Another example:
.PP
.Vb 2
\&    string v[] = { "a b c", "d", "e" };
\&    string arg = (tcl)v;     // arg is "{a b c} d e"
.Ve
.PP
Sometimes you need to assign a group of variables all at once.
You can do this by assigning a list of values to a list of variables:
.PP
.Vb 1
\&    {a, b, c} = {1, 2, 3};
.Ve
.PP
This is more than a short-cut for the three individual assignments.
The entire right-hand side gets evaluated first, then the assignment
occurs, so you can use this to swap the value of two variables:
.PP
.Vb 1
\&    {a, b} = {b, a};
.Ve
.PP
If you want to ignore one of the elements in the right-hand list, you
can put \f(CW\*(C`undef\*(C'\fR in the corresponding element of left-hand list
instead of having to use a dummy variable:
.PP
.Vb 1
\&    {a, undef, b} = {1, 2, 3};  // a gets 1, b gets 3
.Ve
.PP
If the right-hand side list isn't as long as the left-hand list,
the stragglers get \f(CW\*(C`undef\*(C'\fR:
.PP
.Vb 1
\&    {a, b, c} = {1, 2};  // a gets 1, b gets 2, c gets undef
.Ve
.PP
These composite assignments also work with arrays or structs
on the right-hand side:
.PP
.Vb 2
\&    int dev, inode;
\&    struct stat st;
\&
\&    lstat(file, &st);
\&    {dev, inode} = st;  // pull out first two fields of the stat struct
\&
\&    {first, second} = split(line);  // get first two words in line
.Ve
.SH "Html with embedded Little"
.IX Header "Html with embedded Little"
For building web-based applications, Little has a mode where the input
can be \s-1HTML\s0 with embedded Little code (which we call \f(CW\*(C`Lhtml\*(C'\fR).
This works in a way similar to \s-1PHP.\s0
To invoke this mode, the input file must end in .lhtml:
.PP
.Vb 1
\&    L [options] home.lhtml
.Ve
.PP
All text in home.lhtml is passed through to stdout except
that anything between <? and ?> is taken to be one or more
Little statements that are replaced by whatever that Little code outputs,
and anything between <?= and ?> is taken to be a single Little
expression that is replaced by its value.
All Little code is compiled at the global scope, so you can include Little
variable declarations early in the Lhtml document and reference them
later.
.PP
Here's an example that iterates over an array of key/value pairs
and formats them into a rudimentary table:
.PP
.Vb 4
\&    <? key_value_pair row, rows[]; ?>
\&    <html>
\&    <body>
\&    <p>This is a table of data</p>
\&
\&    <table>
\&    <? rows = get_data();
\&       foreach (row in rows) { ?>
\&         <tr>
\&             <td><?= row.key ?></td>
\&             <td><?= row.value ?></td>
\&         </tr>
\&    <? } ?>
\&    </table>
\&
\&    </body>
\&    </html>
.Ve
.SH "Pre-defined identifiers"
.IX Header "Pre-defined identifiers"
.IP "_\|_FILE_\|_" 4
.IX Item "__FILE__"
A string containing the name of the current source file, or \*(L"<stdin>\*(R"
if the script is read from stdin instead of from a file.
Read only.
.IP "_\|_LINE_\|_" 4
.IX Item "__LINE__"
An int containing the current line number within the script.
Read only.
.IP "_\|_FUNC_\|_" 4
.IX Item "__FUNC__"
A string containing the name of the enclosing function.
At the top level, this will contain a unique name created internally
by the compiler to uniquely identify the current file's top-level
code.
Read only.
.IP "\s-1END\s0" 4
.IX Item "END"
An int containing the index of the last character of a non-empty
string or the last element of a non-empty array.  If the array or
string is empty, \s-1END\s0 is \-1.  Valid only inside of a string or array
subscript.  Read only.
.IP "stdio_status" 4
.IX Item "stdio_status"
A struct of type \s-1STATUS \s0(see \fIsystem()\fR) containing status of the
last \fIsystem()\fR, `command`, successful \fIwaitpid()\fR, or failed \fIspawn()\fR.
.IP "undef" 4
.IX Item "undef"
A poly containing the undef value, where defined(undef) is false.
Assigning this to something makes it undefined.
However, undef is not guaranteed to have any particular value, so applications
should not rely on the value.  Read only.
.SH "Reserved words"
.IX Header "Reserved words"
The following identifiers are reserved.  They cannot be used for
variable, function, or type names:
.PP
.Vb 10
\&    break
\&    case
\&    class
\&    constructor
\&    continue
\&    default
\&    defined
\&    destructor
\&    do
\&    else
\&    END
\&    expand
\&    extern
\&    float
\&    for
\&    foreach
\&    goto
\&    if
\&    instance
\&    int
\&    poly
\&    private
\&    public
\&    return
\&    string
\&    struct
\&    switch
\&    typedef
\&    undef
\&    unless
\&    void
\&    while
\&    widget
.Ve
.SH "Debugging"
.IX Header "Debugging"
.SS "Function tracing"
.IX Subsection "Function tracing"
Little function tracing is controlled with #pragma statements, _attribute
clauses in function declarations, command-line options,
environment variables, and a run-time \s-1API.\s0
When a function is marked for tracing,
by default its entry and exit are traced to stderr,
but you can use your own custom hooks
to do anything you want.
.PP
A #pragma takes a comma-separated list of attribute assignments:
.PP
.Vb 9
\&    #pragma fntrace=on
\&    string myfunc(int arg)
\&    {
\&        return("return value");
\&    }
\&    void main()
\&    {
\&        myfunc(123);
\&    }
.Ve
.PP
When this program runs, traces go to stderr with a millisecond
timestamp, the function name, parameter values, and return value:
.PP
.Vb 4
\&    1: enter main
\&    1: enter myfunc: \*(Aq123\*(Aq
\&    2: exit myfunc: \*(Aq123\*(Aq ret \*(Aqreturn value\*(Aq
\&    3: exit main
.Ve
.PP
The allowable tracing attributes are as follows.
.IP "\fBfntrace=on | entry | exit | off\fR" 4
.IX Item "fntrace=on | entry | exit | off"
Enable tracing on both function entry and exit, entry only, exit only,
or disable tracing altogether.
.IP "\fBtrace_depth=n\fR" 4
.IX Item "trace_depth=n"
Trace only to a maximum call depth of n.
.IP "\fBfnhook=myhook\fR" 4
.IX Item "fnhook=myhook"
Use myhook as the trace hook (see below).
.PP
A #pragma stays in effect until overridden by another #pragma or by
an _attribute clause in a function declaration which provides
per-function tracing control:
.PP
.Vb 4
\&    // don\*(Aqt trace this function
\&    void myfunc2(int arg) _attribute (fntrace=off)
\&    {
\&    }
.Ve
.PP
Tracing also can be controlled with command-line options:
.IP "\fB\-\-fntrace =on | entry | exit | off\fR" 4
.IX Item "--fntrace =on | entry | exit | off"
Enable tracing of all functions on both function entry and exit, entry
only, exit only, or disable all tracing.
This overrides any #pragma or _attribute clauses in the program.
.IP "\fB\-\-trace\-out=stdin | stderr | filename | host:port\fR" 4
.IX Item "--trace-out=stdin | stderr | filename | host:port"
Send default trace output to stdin, stderr, a file, or a \s-1TCP\s0 socket.
.IP "\fB\-\-trace\-files=colon\-separated list of glob | /regexp/\fR" 4
.IX Item "--trace-files=colon-separated list of glob | /regexp/"
Enable tracing of all functions in the given files, specified
either as globs or regular expressions.
A + before a glob or regexp enables tracing, a \- disables, and no
+ or \- is like having a +, except that
the leading one is special: if omitted,
it means trace exactly what is specified,
overriding any #pragmas or _attribute clauses in the code,
by first removing all traces and then processing the file list.
.IP "\fB\-\-trace\-funcs=colon\-separated list of glob | /regexp/\fR" 4
.IX Item "--trace-funcs=colon-separated list of glob | /regexp/"
Like trace-files but specifies functions.
.IP "\fB\-\-fnhook=myhook\fR" 4
.IX Item "--fnhook=myhook"
Use \f(CW\*(C`myhook\*(C'\fR as the trace hook, overriding any #pragmas in the program.
.IP "\fB\-\-trace\-script=script.l | Little code\fR" 4
.IX Item "--trace-script=script.l | Little code"
Get the trace hook from a file, or use the given Little code (see below).
.PP
Some examples:
.PP
.Vb 2
\&    # Trace all functions
\&    $ L \-\-fntrace=on myscript.l
\&
\&    # Trace only foo
\&    $ L \-\-trace\-funcs=foo myscript.l
\&
\&    # Trace foo in addition to what the source marks for tracing
\&    $ L \-\-trace\-funcs=+foo myscript.l
\&
\&    # Trace all functions except foo
\&    $ L \-\-trace\-funcs=*:\-foo myscript.l
\&    # This does it too
\&    $ L \-\-fntrace=on \-\-trace\-funcs=\-foo myscript.l
.Ve
.PP
Environment variables also can control tracing and take precedence
over the other ways above:
.PP
.Vb 7
\&    L_TRACE_ALL=on | entry | exit | off
\&    L_TRACE_OUT=stdin | stderr | filename | host:port
\&    L_TRACE_FILES=colon\-separated list of glob | /regexp/
\&    L_TRACE_FUNCS=colon\-separated list of glob | /regexp/
\&    L_TRACE_DEPTH=n
\&    L_TRACE_HOOK=myhook
\&    L_TRACE_SCRIPT=script.l | <Little code>
.Ve
.PP
Things in L_TRACE_FUNCS are applied after things in L_TRACE_FILES.
As with the command-line options, they also can begin with + or \- to
add or subtract from what is specified elsewhere.
.PP
As a short-cut,
.PP
.Vb 1
\&    L_TRACE=stdin | stderr | filename | host:port
.Ve
.PP
traces all functions and sets the trace output location.
.PP
More examples:
.PP
.Vb 2
\&    # Trace all files except foo.l
\&    L_TRACE_FILE=*:\-foo.l L myscript.l
\&
\&    # Trace main() and buggy() in addition to whatever is marked
\&    # for tracing with #pragmas or _attribute clauses in the code.
\&    L_TRACE_FUNCS=+main:buggy L myscript.l
\&
\&    # Trace *only* main() and buggy().
\&    L_TRACE_FUNCS=main:buggy L myscript.l
.Ve
.PP
There also is a run-time \s-1API\s0 that takes a hash of named arguments
analogous to those above:
.PP
.Vb 6
\&    Ltrace({ "fntrace" => "on",
\&             "fnhook_out" => "myhook",
\&             "trace_depth" => 3,
\&             "trace_out" => "tracing.out",
\&             "trace_files" => "foo.l",
\&             "trace_funcs" => "+main:buggy" });
.Ve
.PP
To use your own tracing function, specify \f(CW\*(C`fnhook\*(C'\fR in any of the
above ways.
Your hook is called on function entry and exit instead of
the default hook.
Its prototype must look like this:
.PP
.Vb 1
\&    void myhook(int pre, poly argv[], poly ret);
.Ve
.PP
where pre is 1 when your hook is called upon function entry and 0 when
called upon exit, argv contains the function's arguments
(argv[0] is the function name; argv[1] is the first
parameter), and ret is the return value (exit hook only; it is undef
for entry).
.PP
If you use your own hook and then want to go back to the default,
set \f(CW\*(C`fnhook=def\*(C'\fR.
.PP
To avoid infinite recursion, during the call of a hook, further calls
into the hook are disabled.  Also, functions defined as hooks, and the
Little library functions, are not traced.
.PP
The trace-script attribute is a useful way to provide your own hook:
.PP
.Vb 2
\&    L_TRACE_SCRIPT=my\-trace\-hook.l  // filename must end in .l
\&    L_TRACE_SCRIPT=<Little code>
.Ve
.PP
In the latter case, the Little code gets wrapped in a function like this:
.PP
.Vb 4
\&    void L_fn_hook(int pre, poly av[], poly ret)
\&    {
\&        ...code from L_TRACE_SCRIPT...
\&    }
.Ve
.PP
and \f(CW\*(C`L_fn_hook\*(C'\fR is used as the default trace hook.
.PP
As one example of where this is useful: say you are trying to find
whether the function \f(CW\*(C`foo\*(C'\fR is ever called with the first argument of 123,
and if so, to print all the arguments:
.PP
.Vb 2
\&    L_TRACE_FUNCS=foo \e
\&        L_TRACE_SCRIPT=\*(Aqif (av[0]==123) puts(av)\*(Aq L myscript.l
.Ve
.SH "Built-in and library functions"
.IX Header "Built-in and library functions"
Little has built-in functions and a set of library functions
modeled after the standard C library and Perl.
.IP "string <>" 4
.IX Item "string <>"
.PD 0
.IP "string <\s-1FILE\s0 f>" 4
.IX Item "string <FILE f>"
.PD
Get the next line from a \s-1FILE\s0 handle and return it, or return undef
for \s-1EOF\s0 or errors.  Trailing newlines are removed.  If a file handle
is specified, it is not closed by this function.
.Sp
The form without a file handle
.Sp
.Vb 3
\&    while (buf = <>) {
\&        ...
\&    }
.Ve
.Sp
means
.Sp
.Vb 10
\&    unless (argv[1]) {
\&        while (buf = <stdin>) {
\&            ...
\&        }
\&    } else for (i = 1; argv[i]; i++) {
\&        unless (f = open(argv[i], "r")) {
\&            perror(argv[i]);
\&            continue;
\&        }
\&        while (buf = <f>) {
\&            ...
\&        }
\&    }
.Ve
.Sp
A trivial grep implementation:
.Sp
.Vb 5
\&    void
\&    main(int ac, string argv[])
\&    {
\&        string  regexp = argv[1];
\&        string  buf;
\&
\&        unless (regexp) die("usage: grep regexp [files]");
\&        undef(argv[1]); // left shift down the args
\&        while (buf = <>) {
\&            if (buf =~ m|${regexp}|) puts(buf);
\&        }
\&    }
.Ve
.IP "string `command`" 4
.IX Item "string `command`"
Execute the command (the string enclosed within back-ticks) and
substitute its stdout as the value of the expression.
Any output to stderr is passed through to the calling application's
stderr and is not considered an error.
The command is executed using the Tcl \f(CW\*(C`exec\*(C'\fR command which understands
I/O re-direction and pipes, except that \f(CW\*(C`command\*(C'\fR is split into arguments
using Bourne shell style quoting instead of Tcl quoting (see \f(CW\*(C`shsplit\*(C'\fR).
The command string is interpolated.
Backslash escapes $, `, and \e, \e<newline> is ignored, but otherwise
backslash is literally interpreted.
An embedded newline is an error.
If the command cannot be run, undef is returned.
The global variable \f(CW\*(C`stdio_status\*(C'\fR (see \fIsystem()\fR) contains the
command's exit status.
.IP "int abs(int val)" 4
.IX Item "int abs(int val)"
.PD 0
.IP "float abs(float val)" 4
.IX Item "float abs(float val)"
.PD
Return the absolute value of the argument.
.IP "void assert(int condition)" 4
.IX Item "void assert(int condition)"
Print an error and exit with status 1 if \f(CW\*(C`condition\*(C'\fR is false.
The filename, line number, and text of the condition are printed.
.IP "string basename(string path)" 4
.IX Item "string basename(string path)"
Return the file portion of a path name.
.IP "string caller(int frame)" 4
.IX Item "string caller(int frame)"
Return the name of a calling function, or the caller's caller, etc.
To get the caller, use a frame of 0, to get the caller's caller, use
1, etc.
.IP "int chdir(string dir)" 4
.IX Item "int chdir(string dir)"
Change directory to dir.
Return 0 on success, \-1 on error.
.IP "int chmod(string path, string permissions)" 4
.IX Item "int chmod(string path, string permissions)"
Not available on Windows.
Change the mode of the file or directory named by path.  Permissions
can be the octal code that \fIchmod\fR\|(1) uses, or symbolic attributes that
\&\fIchmod\fR\|(1) uses of the form [ugo]?[[+\-=][rwxst],[...]], where multiple
symbolic attributes can be separated by commas (example: u+s,go\-rw add
sticky bit for user, remove read and write permissions for group and
other).  A simplified ls-style string, of the form rwxrwxrwx (must be 9
characters), is also supported (example: rwxr-xr-t is equivalent to
01755).
Return 0 on success, \-1 on error.
.IP "int chown(string owner, string group, string path)" 4
.IX Item "int chown(string owner, string group, string path)"
Not available on Windows.
Change the file ownership of the file or directory names by path.  If
either owner or group is an empty string, the attribute will not be
modified.
Return 0 on success, \-1 on error.
.IP "int \fIcpus()\fR" 4
.IX Item "int cpus()"
Return the number of processors (if known).  Defaults to 1.
.IP "void die(string fmt, ...args)" 4
.IX Item "void die(string fmt, ...args)"
Output a printf-like message to stderr and exit 1.
If fmt does not end with a newline, append
\&\*(L" in <filename> at line <linenum>.\en\*(R"
.IP "string dirname(string path)" 4
.IX Item "string dirname(string path)"
Return the directory portion of a pathname.
.IP "int eq(compositeType a, compositeType b)" 4
.IX Item "int eq(compositeType a, compositeType b)"
Compare two arrays, hashes, structs, or lists for equality.
The two arguments are compared recursively element by element.
.IP "int exists(string path)" 4
.IX Item "int exists(string path)"
Return 1 if the given path exists or 0 if it does not exist.
.IP "int fclose(\s-1FILE\s0 f)" 4
.IX Item "int fclose(FILE f)"
Close an open \s-1FILE\s0 handle.
Return 0 on success, \-1 on error.
.IP "\s-1FILE\s0 fopen(string path, string mode)" 4
.IX Item "FILE fopen(string path, string mode)"
Open a file.  The \f(CW\*(C`mode\*(C'\fR string indicates how the file will be accessed.
.RS 4
.ie n .IP """r""" 4
.el .IP "``r''" 4
.IX Item "r"
Open the file for reading only; the file must already exist. This is
the default value if access is not specified.
.ie n .IP """r+""" 4
.el .IP "``r+''" 4
.IX Item "r+"
Open the file for both reading and writing; the file must already exist.
.ie n .IP """w""" 4
.el .IP "``w''" 4
.IX Item "w"
Open the file for writing only. Truncate it if it exists. If it
doesn't exist, create a new file.
.ie n .IP """w+""" 4
.el .IP "``w+''" 4
.IX Item "w+"
Open the file for reading and writing. Truncate it if it exists. If it
doesn't exist, create a new file.
.ie n .IP """a""" 4
.el .IP "``a''" 4
.IX Item "a"
Open the file for writing only. The file must already exist, and the
file is positioned so that new data is appended to the file.
.ie n .IP """a+""" 4
.el .IP "``a+''" 4
.IX Item "a+"
Open the file for reading and writing. If the file doesn't exist,
create a new empty file. Set the initial access position to the end of
the file.
.ie n .IP """v""" 4
.el .IP "``v''" 4
.IX Item "v"
This mode can be added to any of the above and causes open errors to
be written to stderr.
.RE
.RS 4
.Sp
Return a \s-1FILE\s0 handle on success and undef on error.
.RE
.IP "int fprintf(\s-1FILE\s0 f, string fmt, ...args)" 4
.IX Item "int fprintf(FILE f, string fmt, ...args)"
Format and print a string to the given \s-1FILE\s0 handle.  The \s-1FILE\s0 handles
\&\f(CW\*(C`stdin\*(C'\fR, \f(CW\*(C`stdout\*(C'\fR, and \f(CW\*(C`stderr\*(C'\fR are pre-defined.
.Sp
Return 0 on success, \-1 on error.
.IP "int Fprintf(string filename, string fmt, ...args)" 4
.IX Item "int Fprintf(string filename, string fmt, ...args)"
Like fprintf but write to the given file name.  The file is
overwritten if it already exists.  Return 0 on success, \-1 on error.
.IP "string ftype(string path)" 4
.IX Item "string ftype(string path)"
Return the type of file at the given path. Type can be \f(CW\*(C`directory\*(C'\fR, \f(CW\*(C`file\*(C'\fR,
\&\f(CW\*(C`character\*(C'\fR, \f(CW\*(C`block\*(C'\fR, \f(CW\*(C`fifo\*(C'\fR, \f(CW\*(C`symlink\*(C'\fR or \f(CW\*(C`socket\*(C'\fR.
Return undef on error.
.IP "string[] getdir(string dir)" 4
.IX Item "string[] getdir(string dir)"
.PD 0
.IP "string[] getdir(string dir, string pattern)" 4
.IX Item "string[] getdir(string dir, string pattern)"
.PD
Return the files in the given directory, as a sorted string array.
Optionally filter the list by \f(CW\*(C`pattern\*(C'\fR which is a glob and may
contain the following special characters:
.RS 4
.IP "?" 4
Matches any single character.
.IP "*" 4
Matches any sequence of zero or more characters.
.IP "[chars]" 4
.IX Item "[chars]"
Matches any single character in chars. If chars contains a sequence of
the form a\-b then any character between a and b (inclusive) will
match.
.IP "\ex" 4
.IX Item "x"
Matches the character x.
.IP "{a,b,...}" 4
.IX Item "{a,b,...}"
Matches any of the strings a, b, etc.
.RE
.RS 4
.Sp
If the first character in a pattern is ``~'' then it refers to the
home directory for the user whose name follows the ``~''. If the ``~''
is followed immediately by ``/'' then the value of the \s-1HOME\s0
environment variable is used.
.RE
.IP "dirent[] getdirx(string dir)" 4
.IX Item "dirent[] getdirx(string dir)"
Return the files in the given directory as an array of structs, with
the directories sorted and coming first in the array followed by
the sorted file names.
Return undef on error.
The \f(CW\*(C`dirent\*(C'\fR struct is defined as follows:
.RS 4
.Sp
.Vb 5
\&    typedef struct dirent {
\&        string  name;
\&        string  type;    // "file", "directory", "other"
\&        int     hidden;
\&    } dirent;
.Ve
.RE
.RS 4
.RE
.IP "string getenv(string varname)" 4
.IX Item "string getenv(string varname)"
Return the value of an environment variable if it exists and is of
non-zero length, or return undef if it has zero length or does not
exist.
This allows you to say putenv(\*(L"VAR=\*(R") and have getenv(\*(L"\s-1VAR\*(R"\s0) return
undef.
.IP "string getopt(string av[], string opts, string longopts[])" 4
.IX Item "string getopt(string av[], string opts, string longopts[])"
Parse command-line argument
This version (from BitKeeper, same semantics)
recognizes the following types of short and long options in the av array:
.Sp
.Vb 10
\&    \-            leaves it and stops processing options
\&                 (for indicating stdin)
\&    \-\-           end of options
\&    \-a
\&    \-abcd
\&    \-r <arg>
\&    \-r<arg>
\&    \-abcr <arg>  same as \-a \-b \-c \-r <arg>
\&    \-abcr<arg>   same as \-a \-b \-c \-r<arg>
\&    \-r<arg> 
\&    \-\-long
\&    \-\-long:<arg>
\&    \-\-long=<arg>
\&    \-\-long <arg>
.Ve
.Sp
Short options are all specified in a single \f(CW\*(C`opts\*(C'\fR string as follows:
.Sp
.Vb 4
\&    d           boolean option          \-d
\&    d:          required arg            \-dARG or \-d ARG
\&    d;          required arg no space   \-dARG
\&    d|          optional arg no space   \-dARG or \-d
.Ve
.Sp
Long options are specified in the \f(CW\*(C`longopts\*(C'\fR array (one option
per element) as follows:
.Sp
.Vb 4
\&    long        boolean option          \-\-long
\&    long:       required arg            \-\-long=ARG or \-\-long ARG
\&    long;       required arg no space   \-\-long=ARG
\&    long|       optional arg no space   \-\-long=ARG or \-\-long
.Ve
.Sp
The function returns the name of the next recognized option or
undef if no more options exist.
The global variable \f(CW\*(C`optind\*(C'\fR is set to the next av[] index to
process.
If the option has no arg, \f(CW\*(C`optarg\*(C'\fR is set to \f(CW\*(C`undef\*(C'\fR.
.Sp
If an unrecognized option is seen, the empty string ("") is returned
and the global variable \f(CW\*(C`optopt\*(C'\fR is set to the name of the
offending option (unless the option is a long option).
.Sp
This example shows a typical usage of both short and long options.
.Sp
.Vb 2
\&    int     debug_level, verbose;
\&    string  c, lopts[] = { "verbose" };
\&
\&    while (c = getopt(av, "d|v", lopts)) {
\&        switch (c) {
\&            case "d":
\&                if (optarg) debug_level = (int)optarg;
\&                break;
\&            case "v":
\&            case "verbose":
\&                verbose = 1;
\&                break;
\&            default:
\&                die("unrecognized option ${optopt}");
\&        }
\&    }
.Ve
.IP "int \fIgetpid()\fR" 4
.IX Item "int getpid()"
Return the caller's process id.
.IP "void \fIhere()\fR" 4
.IX Item "void here()"
Output a message like \*(L"\fImyfunc()\fR in script.l:86\*(R" to stderr which
contains the file name, line number, and currently executing function
name.
Typically used for debugging.
.IP "void insert(type &array[], int index, type elem | type elems[], ...)" 4
.IX Item "void insert(type &array[], int index, type elem | type elems[], ...)"
Insert one or more elements into \f(CW\*(C`array\*(C'\fR before the element specified
by \f(CW\*(C`index\*(C'\fR.
If \f(CW\*(C`index\*(C'\fR is 0, the elements are inserted at the beginning of the
array; this is what \f(CW\*(C`unshift()\*(C'\fR does.
If \f(CW\*(C`index\*(C'\fR is \-1 or larger than or equal to the number of elements in
the array, the elements are inserted at the end; this is what \f(CW\*(C`push\*(C'\fR does.
You can insert single elements or arrays of elements.
.IP "int isalpha(string s)" 4
.IX Item "int isalpha(string s)"
Return 1 if the given string contains only alphabetic characters, else
return 0.
An empty string also returns 0.
.IP "int isalnum(string s)" 4
.IX Item "int isalnum(string s)"
Return 1 if the given string contains only alphabetic or digit characters, else
return 0.
An empty string also returns 0.
.IP "int isdigit(string s)" 4
.IX Item "int isdigit(string s)"
Return 1 if the given string contains only digit characters, else
return 0.
An empty string also returns 0.
.IP "int isdir(string path)" 4
.IX Item "int isdir(string path)"
Return 1 if the given path exists and is a directory, else return 0.
.IP "int islink(string path)" 4
.IX Item "int islink(string path)"
Return 1 if the given path exists and is a link, else return 0.
.IP "int islower(string s)" 4
.IX Item "int islower(string s)"
Return 1 if the given string contains only lower case alphabetic characters, else
return 0.
An empty string also returns 0.
.IP "int isreg(string path)" 4
.IX Item "int isreg(string path)"
Return 1 if the given path exists and is a regular file, else return 0.
.IP "int isspace(string buf)" 4
.IX Item "int isspace(string buf)"
Return 1 if all characters in the argument are space characters, else
return 0.
An empty string also returns 0.
.IP "int isupper(string s)" 4
.IX Item "int isupper(string s)"
Return 1 if the given string contains only upper-case alphabetic characters, else
return 0.
An empty string also returns 0.
.IP "int iswordchar(string s)" 4
.IX Item "int iswordchar(string s)"
Return 1 if the given string contains only alphanumeric or connector
punctuation characters (such as underscore), else return 0.
An empty string also returns 0.
.IP "string join(string sep, type array[])" 4
.IX Item "string join(string sep, type array[])"
Convert an array into a string by joining all of its elements by
inserting sep between each pair.
.IP "keyType[] keys(valType hash{keyType})" 4
.IX Item "keyType[] keys(valType hash{keyType})"
Return an array containing the keys of a given hash.  Note that the
return type depends on the argument type.
.IP "string lc(string s)" 4
.IX Item "string lc(string s)"
Return a copy of the string that is in all lower case.
.IP "int length(string s)" 4
.IX Item "int length(string s)"
Return the number of characters in the given string.
Returns 0 if the argument is \f(CW\*(C`undef\*(C'\fR.
.IP "int length(type array[])" 4
.IX Item "int length(type array[])"
Return the number of elements in the given array.
Returns 0 if the argument is \f(CW\*(C`undef\*(C'\fR.
.Sp
.Vb 1
\&        for (i = 0; i < length(array); i++)
.Ve
.IP "int length(valType hash{keyType})" 4
.IX Item "int length(valType hash{keyType})"
Return the number of key/value pairs in the given hash.
Returns 0 if the argument is \f(CW\*(C`undef\*(C'\fR.
.IP "int link(string sourcePath, string targetPath)" 4
.IX Item "int link(string sourcePath, string targetPath)"
Create a hard link from sourcePath to targetPath.
Return 0 on success, \-1 on error.
.IP "int lstat(string path, struct stat &buf)" 4
.IX Item "int lstat(string path, struct stat &buf)"
Call \fIlstat\fR\|(2) on \f(CW\*(C`path\*(C'\fR and place the information in \f(CW\*(C`buf\*(C'\fR.
Return 0 on success, \-1 on error.
The \f(CW\*(C`struct stat\*(C'\fR type is defined as follows:
.Sp
.Vb 10
\&    struct stat {
\&        int     st_dev;
\&        int     st_ino;
\&        int     st_mode;
\&        int     st_nlink;
\&        int     st_uid;
\&        int     st_gid;
\&        int     st_size;
\&        int     st_atime;
\&        int     st_mtime;
\&        int     st_ctime;
\&        string  st_type;
\&    };
.Ve
.Sp
where \f(CW\*(C`st_type\*(C'\fR is a string giving the type of file name, which will
be one of file, directory, characterSpecial, blockSpecial, fifo, link,
or socket.
.IP "int|float max(int|float, int|float)" 4
.IX Item "int|float max(int|float, int|float)"
.PD 0
.IP "int|float min(int|float, int|float)" 4
.IX Item "int|float min(int|float, int|float)"
.PD
Return the maximum or minimum of two numbers.  The return type is
float if either of the arguments is a float, otherwise the return type
is int.
.IP "int \fImilli()\fR" 4
.IX Item "int milli()"
Return the number of milliseconds since the currently executing
script started.
.IP "void \fImilli_reset()\fR" 4
.IX Item "void milli_reset()"
Reset the internal state for \fImilli()\fR to begin counting from 0 again.
.IP "int mkdir(string path)" 4
.IX Item "int mkdir(string path)"
Create a directory at the given path.  This creates all non-existing
parent directories.  The directories are created with mode 0775
(rwxrwxr-x).
Return 0 on success, \-1 on error.
.IP "int mtime(string path)" 4
.IX Item "int mtime(string path)"
Return the modified time of path, or 0 to indicate error.
.IP "string normalize(string path)" 4
.IX Item "string normalize(string path)"
Return a normalized version of path. The pathname will be an absolute
path with all \*(L"../\*(R" and \*(L"./\*(R" removed.
.IP "int ord(string c)" 4
.IX Item "int ord(string c)"
Return the numeric value of the encoding (\s-1ASCII,\s0 Unicode) of the first character
of \f(CW\*(C`c\*(C'\fR, or \-1 on error or if \f(CW\*(C`c\*(C'\fR is the empty string.
.IP "int pclose(\s-1FILE\s0 f)" 4
.IX Item "int pclose(FILE f)"
.PD 0
.IP "int pclose(\s-1FILE\s0 f, \s-1STATUS\s0 &s)" 4
.IX Item "int pclose(FILE f, STATUS &s)"
.PD
Close an open pipe created by \fIpopen()\fR.
Return 0 on success, \-1 on error.
See \fIsystem()\fR for details of the \s-1STATUS\s0 struct.
.IP "void \fIperror()\fR" 4
.IX Item "void perror()"
.PD 0
.IP "void perror(string message)" 4
.IX Item "void perror(string message)"
.PD
Print the error message corresponding to the last error from
various Little library calls.
If \f(CW\*(C`message\*(C'\fR is not undef, it is prepended to the error string
with a \*(L": \*(R".
.IP "type pop(type &array[])" 4
.IX Item "type pop(type &array[])"
Remove an element from the end of \f(CW\*(C`array\*(C'\fR.
Return undef if the array is already empty.
.IP "\s-1FILE\s0 popen(string cmd | argv[], string mode)" 4
.IX Item "FILE popen(string cmd | argv[], string mode)"
.PD 0
.IP "\s-1FILE\s0 popen(string cmd | argv[], string mode, void &stderr_callback(string cmd, \s-1FILE\s0 f))" 4
.IX Item "FILE popen(string cmd | argv[], string mode, void &stderr_callback(string cmd, FILE f))"
.PD
Open a file handle to a process running the command specified in 
\&\f(CW\*(C`argv[]\*(C'\fR or \f(CW\*(C`cmd\*(C'\fR.  In the \f(CW\*(C`cmd\*(C'\fR case, the command is split into
arguments respecting Bourne shell style quoting.
The returned \s-1FILE\s0 handle may be
used to write to the command's input pipe or read from its output
pipe, depending on the value of \f(CW\*(C`mode\*(C'\fR.  If write-only access is used
(\*(L"w\*(R"), then standard output for the pipeline is directed to the
current standard output unless overridden by the command.  If
read-only access is used (\*(L"r\*(R"), standard input for the pipeline is
taken from the current standard input unless overridden by the
command.
.Sp
The optional third argument is a callback function that is
invoked by Tcl's event loop when the command's stderr pipe has data
available to be read.
The second argument of the callback is a non-blocking \s-1FILE\s0 for the
read end of this pipe.
Care must be taken to ensure that the event loop is run often enough
for the callback to reap data from the pipe often enough to avoid deadlock.
In console apps, this may mean calling Tcl's \f(CW\*(C`update()\*(C'\fR function.
The \fIpclose()\fR function also invokes the callback, so it is guaranteed to
be called at least once.
.Sp
If the third argument to \f(CW\*(C`popen\*(C'\fR is \f(CW\*(C`undef\*(C'\fR, the command's stderr
output is ignored.  Otherwise, unless re-directed by the command, any
stderr output is passed through to the calling script's stderr and is
not considered an error.
.Sp
If Tk is being used, there is a default callback that pops up a window
with any output the command writes to stderr.
.Sp
Return the \s-1FILE\s0 handle on success, or undef on error.
.IP "int printf(string fmt, ...args)" 4
.IX Item "int printf(string fmt, ...args)"
Format arguments and print to stdout, as in \fIprintf\fR\|(3).
Return 0 on success, \-1 on error.
.IP "void push(type &array[], type element1 | type elements1[], ...)" 4
.IX Item "void push(type &array[], type element1 | type elements1[], ...)"
Push one or more elements onto the end of \f(CW\*(C`array\*(C'\fR.
You can insert single elements or arrays of elements.
.IP "string putenv(string var_fmt, ...args)" 4
.IX Item "string putenv(string var_fmt, ...args)"
Set an environment variable, overwriting any pre-existing value,
using printf-like arguments:
.Sp
.Vb 2
\&        putenv("VAR=val");
\&        putenv("MYPID=%d", getpid());
.Ve
.Sp
Return the new value or undef if var_fmt contains no \*(L"=\*(R".
.IP "int read(\s-1FILE\s0 f, string &buffer)" 4
.IX Item "int read(FILE f, string &buffer)"
.PD 0
.IP "int read(\s-1FILE\s0 f, string &buffer, int numBytes)" 4
.IX Item "int read(FILE f, string &buffer, int numBytes)"
.PD
Read at most numBytes from the given \s-1FILE\s0 handle into the buffer, or
read the entire file if numBytes == \-1 or is omitted.  Return the number of
bytes read, \-1 on error or \s-1EOF.\s0
.IP "int rename(string oldpath, string newpath)" 4
.IX Item "int rename(string oldpath, string newpath)"
Rename a file.
Return 0 on success, \-1 on error.
.IP "string require(string packageName)" 4
.IX Item "string require(string packageName)"
Find and load the given Tcl package packageName.  Return the version
string of the package loaded on success, and undef on error.
.IP "int rmdir(string dir)" 4
.IX Item "int rmdir(string dir)"
Delete the given directory.
Return 0 on success, \-1 on error.
.IP "type shift(type &array[])" 4
.IX Item "type shift(type &array[])"
Remove and return the element at the beginning of \f(CW\*(C`array\*(C'\fR.
Return undef if the array is already empty.
.IP "string[] shsplit(string cmd)" 4
.IX Item "string[] shsplit(string cmd)"
Split the string the same way as the Bourne shell and return the array.
.IP "int size(string path)" 4
.IX Item "int size(string path)"
Return the size, in bytes, of the named file path, or \-1 on error.
.IP "void sleep(float seconds)" 4
.IX Item "void sleep(float seconds)"
Sleep for \f(CW\*(C`seconds\*(C'\fR seconds.  Note that \f(CW\*(C`seconds\*(C'\fR can be fractional to 
get sub-second sleeps.
.IP "type[] sort(type[] array)" 4
.IX Item "type[] sort(type[] array)"
.PD 0
.IP "type[] sort([decreasing: | increasing:], type[] array)" 4
.IX Item "type[] sort([decreasing: | increasing:], type[] array)"
.IP "type[] sort([integer: | real: | ascii:], type[] array)" 4
.IX Item "type[] sort([integer: | real: | ascii:], type[] array)"
.IP "type[] sort(command: &compar, type[] array)" 4
.IX Item "type[] sort(command: &compar, type[] array)"
.PD
Sort the array \f(CW\*(C`array\*(C'\fR and return a new array of sorted elements.
The first variation sorts the elements into ascending order, and does
an integer, real, or ascii sort based on the type of \f(CW\*(C`array\*(C'\fR.  The
second two variations show optional arguments that can be passed to
change this behavior.  The last variation shows how a custom compare
function can be specified.  The function must take two array elements
of type T as arguments and return \-1 if the first comes before the
second in the sort order, +1 if the first comes after the second, and
0 if the two are equal.
.IP "int spawn(string cmd)" 4
.IX Item "int spawn(string cmd)"
.PD 0
.IP "int spawn(string cmd, \s-1STATUS\s0 &s)" 4
.IX Item "int spawn(string cmd, STATUS &s)"
.IP "int spawn(string argv[])" 4
.IX Item "int spawn(string argv[])"
.IP "int spawn(string argv[], \s-1STATUS\s0 &s)" 4
.IX Item "int spawn(string argv[], STATUS &s)"
.IP "int spawn(cmd | argv[], \s-1FILE\s0 in, \s-1FILE\s0 out, \s-1FILE\s0 err)" 4
.IX Item "int spawn(cmd | argv[], FILE in, FILE out, FILE err)"
.IP "int spawn(cmd | argv[], \s-1FILE\s0 in, \s-1FILE\s0 out, \s-1FILE\s0 err, \s-1STATUS\s0 &s)" 4
.IX Item "int spawn(cmd | argv[], FILE in, FILE out, FILE err, STATUS &s)"
.IP "int spawn(cmd | argv[], string in, \s-1FILE\s0 out, \s-1FILE\s0 err)" 4
.IX Item "int spawn(cmd | argv[], string in, FILE out, FILE err)"
.IP "int spawn(cmd | argv[], string in, \s-1FILE\s0 out, \s-1FILE\s0 err, \s-1STATUS\s0 &s)" 4
.IX Item "int spawn(cmd | argv[], string in, FILE out, FILE err, STATUS &s)"
.IP "int spawn(cmd | argv[], string[] in, \s-1FILE\s0 out, \s-1FILE\s0 err)" 4
.IX Item "int spawn(cmd | argv[], string[] in, FILE out, FILE err)"
.IP "int spawn(cmd | argv[], string[] in, \s-1FILE\s0 out, \s-1FILE\s0 err, \s-1STATUS\s0 &s)" 4
.IX Item "int spawn(cmd | argv[], string[] in, FILE out, FILE err, STATUS &s)"
.ie n .IP "int spawn(cmd | argv[], ""input"", ""${outf}"", ""errors"")" 4
.el .IP "int spawn(cmd | argv[], ``input'', ``${outf}'', ``errors'')" 4
.IX Item "int spawn(cmd | argv[], input, ${outf}, errors)"
.ie n .IP "int spawn(cmd | argv[], ""input"", ""${outf}"", ""errors"", \s-1STATUS\s0 &s)" 4
.el .IP "int spawn(cmd | argv[], ``input'', ``${outf}'', ``errors'', \s-1STATUS\s0 &s)" 4
.IX Item "int spawn(cmd | argv[], input, ${outf}, errors, STATUS &s)"
.PD
Execute a command in background.  All forms return either a process id or
undef to indicate an error.
In the error case the \s-1STATUS\s0 argument is set, otherwise it remains untouched
and the status can be reaped by \fIwaitpid()\fR.
.Sp
See the \fIsystem()\fR function for information about the arguments.
.Sp
See the \fIwaitpid()\fR function for information about waiting on the child.
.IP "string[] split(string s)" 4
.IX Item "string[] split(string s)"
.PD 0
.IP "string[] split(/regexp/, string s)" 4
.IX Item "string[] split(/regexp/, string s)"
.IP "string[] split(/regexp/, string s, int limit)" 4
.IX Item "string[] split(/regexp/, string s, int limit)"
.PD
Split a string into substrings.
In the first variation, the string is split on whitespace, and any
leading or trailing white space does not produce a null field in the result.
This is useful when you just want to get at the things delimited
by the white space:
.Sp
.Vb 2
\&    split("a b c");    // returns {"a", "b", "c"}
\&    split(" x y z ");  // returns {"x", "y", "z"}
.Ve
.Sp
In the second variation, the string is split using a regular expression
as the delimiter:
.Sp
.Vb 3
\&    split(/,/, "we,are,commas");  // returns {"we", "are", "commas"}
\&    split(/xxx/, "AxxxBxxxC");    // returns {"A", "B", "C"}
\&    split(/[;,]/, "1;10,20");     // returns {"1", "10", "20"}
.Ve
.Sp
When a delimiter is used, split returns a null first field if the
string begins with the delimiter, but if the string ends with the
delimiter no trailing null field is returned.  This provides
compatibility with Perl's split:
.Sp
.Vb 1
\&    split(/xx/, "xxAxxBxxCxx");  // returns {"", "A", "B", "C"}
.Ve
.Sp
You can avoid the leading null fields in the result if you put a
\&\f(CW\*(C`t\*(C'\fR after the regular expression (to tell it to \*(L"trim\*(R" the result):
.Sp
.Vb 1
\&    split(/xx/t, "xxAxxBxxCxx");  // returns {"A", "B", "C"}
.Ve
.Sp
If a \f(CW\*(C`limit\*(C'\fR argument is given, at most \f(CW\*(C`limit\*(C'\fR substrings are returned
(limit <= 0 means no limit):
.Sp
.Vb 1
\&    split(/ /, "a b c d e f", 3);  // returns {"a", "b", "c d e f"}
.Ve
.Sp
To allow splitting on variables or function calls that start with
\&\f(CW\*(C`m\*(C'\fR, the alternate regular expression delimiter syntax
is restricted:
.Sp
.Vb 4
\&    split(m|/|, pathname);  // "|" and most other punctuation \-\- ok
\&                            // but ( and ) as delimiters \-\- error
\&    split(m);               // splits the variable "m" \-\- ok
\&    split(m(arg));          // splits the result of m(arg) \-\- ok
.Ve
.Sp
Regular expressions, and the strings to split,
both can contain unicode characters or binary data as well as \s-1ASCII:\s0
.Sp
.Vb 2
\&    split(/\e0/, string_with_nulls);  // split on null
\&    split(/X/, "XX XXXX XXXX");      // unicode regexp and string
.Ve
.IP "string sprintf(string fmt, ...args)" 4
.IX Item "string sprintf(string fmt, ...args)"
Format arguments and return a formatted string like \fIsprintf\fR\|(3).
Return undef on error.
.IP "int stat(string path, struct stat &buf)" 4
.IX Item "int stat(string path, struct stat &buf)"
Call \fIstat\fR\|(2) on \f(CW\*(C`path\*(C'\fR and place the information in \f(CW\*(C`buf\*(C'\fR.
Return 0 on success, \-1 on error.
See the \fIlstat()\fR command for the definition of \f(CW\*(C`struct stat\*(C'\fR.
.IP "int strchr(string s, string c)" 4
.IX Item "int strchr(string s, string c)"
Return the first index of c into s, or \-1 if c is not found.
.IP "int strlen(string s)" 4
.IX Item "int strlen(string s)"
Return the string length.
.IP "int strrchr(string s, string c)" 4
.IX Item "int strrchr(string s, string c)"
Return the last index of c into s, or \-1 if c is not found.
.IP "int symlink(string sourcePath, string targetPath)" 4
.IX Item "int symlink(string sourcePath, string targetPath)"
Create a symbolic link from sourcePath to targetPath.
Return 0 on success, \-1 on failure.
.IP "int system(string cmd)" 4
.IX Item "int system(string cmd)"
.PD 0
.IP "int system(string cmd, \s-1STATUS\s0 &s)" 4
.IX Item "int system(string cmd, STATUS &s)"
.IP "int system(string argv[])" 4
.IX Item "int system(string argv[])"
.IP "int system(string argv[], \s-1STATUS\s0 &s)" 4
.IX Item "int system(string argv[], STATUS &s)"
.IP "int system(cmd | argv[], string in, string &out, string &err)" 4
.IX Item "int system(cmd | argv[], string in, string &out, string &err)"
.IP "int system(cmd | argv[], string in, string &out, string &err, \s-1STATUS\s0 &s)" 4
.IX Item "int system(cmd | argv[], string in, string &out, string &err, STATUS &s)"
.IP "int system(cmd | argv[], string[] in, string[] &out, string[] &err)" 4
.IX Item "int system(cmd | argv[], string[] in, string[] &out, string[] &err)"
.IP "int system(cmd | argv[], string[] in, string[] &out, string[] &err, \s-1STATUS\s0 &s)" 4
.IX Item "int system(cmd | argv[], string[] in, string[] &out, string[] &err, STATUS &s)"
.IP "int system(cmd | argv[], \s-1FILE\s0 in, \s-1FILE\s0 out, \s-1FILE\s0 err);" 4
.IX Item "int system(cmd | argv[], FILE in, FILE out, FILE err);"
.IP "int system(cmd | argv[], \s-1FILE\s0 in, \s-1FILE\s0 out, \s-1FILE\s0 err, \s-1STATUS\s0 &s);" 4
.IX Item "int system(cmd | argv[], FILE in, FILE out, FILE err, STATUS &s);"
.ie n .IP "int system(cmd | argv[], ""input"", ""${outf}"", ""errors"")" 4
.el .IP "int system(cmd | argv[], ``input'', ``${outf}'', ``errors'')" 4
.IX Item "int system(cmd | argv[], input, ${outf}, errors)"
.ie n .IP "int system(cmd | argv[], ""input"", ""${outf}"", ""errors"", \s-1STATUS\s0 &s)" 4
.el .IP "int system(cmd | argv[], ``input'', ``${outf}'', ``errors'', \s-1STATUS\s0 &s)" 4
.IX Item "int system(cmd | argv[], input, ${outf}, errors, STATUS &s)"
.PD
Execute a command and wait for it to finish (see \f(CW\*(C`spawn()\*(C'\fR for the
asynchronous version).
.Sp
The command is executed using Tcl's \f(CW\*(C`exec\*(C'\fR which understands
I/O re-direction and pipes, except that \f(CW\*(C`command\*(C'\fR is split into arguments
using Bourne shell style quoting instead of Tcl quoting (see \f(CW\*(C`shsplit\*(C'\fR).
.Sp
If the number of arguments is one or two, then the existing stdin,
stdout, stderr channels are used.
.Sp
If the number of arguments is four or five, then the second, third,
and fourth arguments specify stdin, stdout, stderr, respectively.
Each can be a string variable or string array
(a reference is required for stdout and stderr),
a \s-1FILE\s0 variable which must be an open file handle, or
a string literal which is interpreted as a file path name.
If you want to specify a file name from a variable, use the string
literal \*(L"${filename}\*(R".
It is an error to both re-direct input/output in the command string
and to specify the corresponding input/output argument; in such a
case, the command is not run and \f(CW\*(C`undef\*(C'\fR is returned.
.Sp
If stdout or stderr are sent to strings or string arrays and no output
is produced, then \f(CW\*(C`out\*(C'\fR or \f(CW\*(C`err\*(C'\fR are \f(CW\*(C`undef\*(C'\fR upon return.
.Sp
The optional last argument is a reference to the following structure:
.Sp
.Vb 8
\&    typedef struct {
\&        string  argv[]; // args passed in
\&        string  path;   // if defined, this is the path to the exe
\&                        // if undef, the executable was not found
\&        int     exit;   // if defined, the process exited with <exit>
\&        int     signal; // if defined, the process was killed
\&                        // by <signal>
\&    } STATUS;
.Ve
.Sp
The global variable \f(CW\*(C`stdio_status\*(C'\fR is also set.
If the the command is a pipeline and a process in that pipeline fails,
the returned status is for the first process that failed.
.Sp
If there is an error executing the command, or if the process
is killed by a signal, undef is returned;
otherwise, the return value is the
process exit status (for a pipeline, the status of the first process
that exited with error).
.Sp
Examples:
.Sp
.Vb 2
\&    // No futzing with input/output, uses stdin/out/err.
\&    ret = system(cmd);
\&
\&    // Same thing but no quoting issues, like execve(2).
\&    ret = system(argv);
\&
\&    // Get detailed status.
\&    unless (defined(ret = system(cmd, &status))) {
\&        unless (defined(status.path)) {
\&                warn("%s not found or bad perm\en", status.path);
\&        }
\&        if (defined(status.signal)) {
\&                warn("%s killed with %d\en",
\&                    status.argv[0], status.signal);
\&        }
\&    }
\&
\&    // Taking input and sending output to string arrays.
\&    // The in_vec elements should not contain newlines and
\&    // the out/err_vec elements will not contain newlines.
\&    string in_vec[], out_vec[], err_vec[];
\&    ret = system(cmd, in_vec, &out_vec, &err_vec);
\&
\&    // Taking input and sending output to files.
\&    string outf = sprintf("/tmp/out%d", getpid());
\&    ret = system(cmd, "/etc/passwd", "${outf}", "/tmp/errors");
\&
\&    // Using open file handles.
\&    FILE in = popen("/some/producer/process", "r");
\&    FILE out = popen("/some/consumer/process", "w");
\&    FILE err = popen("cat > /dev/tty", "w");
\&    ret = system(argv, buf, in, out, err, &status);
\&    // error handling here
\&    pclose(in, &status);
\&    // error handling here
\&    ...
\&
\&    // Mixing and matching.
\&    ret = system(argv, buf, &out, "/tmp/errors", &status);
.Ve
.IP "string trim(string s)" 4
.IX Item "string trim(string s)"
Return a copy of the string that has been trimmed of any leading and
trailing whitespace (spaces, tabs, newlines, and carriage returns).
.IP "string typeof(<variable>)" 4
.IX Item "string typeof(<variable>)"
Return the simple type name of the given variable.
This is one of \*(L"int\*(R", \*(L"string\*(R", \*(L"poly\*(R", \*(L"widget\*(R", \*(L"array\*(R",
\&\*(L"hash\*(R", or \*(L"struct\*(R";
or if the variable's type is a typedef, the typedef name;
or if the variable has a class type, the class name;
of if the variable is really a function name, \*(L"function\*(R".
.IP "string uc(string s)" 4
.IX Item "string uc(string s)"
Return a copy of the string that is in all upper case.
.IP "void undef(<array>[index])" 4
.IX Item "void undef(<array>[index])"
.PD 0
.IP "void undef(<string>[index])" 4
.IX Item "void undef(<string>[index])"
.IP "void undef(<hash>{index})" 4
.IX Item "void undef(<hash>{index})"
.IP "void undef(<variable>)" 4
.IX Item "void undef(<variable>)"
.PD
In the first three forms, remove an array, string, or hash element
from the specified variable.
In the last form, sets the variable to undef.
When setting a hash or array to undef, all of its old elements are
freed (unless they were shared with some other variable).
.IP "int unlink(string path)" 4
.IX Item "int unlink(string path)"
Delete the named file.
Return 0 on success, \-1 on failure.
.IP "void unshift(type &array[], type element1 | type elements1[], ...)" 4
.IX Item "void unshift(type &array[], type element1 | type elements1[], ...)"
Add one or more elements onto the beginning of \f(CW\*(C`array\*(C'\fR.
You can insert single elements or arrays of elements.
.IP "int waitpid(int pid, \s-1STATUS\s0 &status, int nohang)" 4
.IX Item "int waitpid(int pid, STATUS &status, int nohang)"
Given a pid returned by \fIspawn()\fR, wait for it, and place the exit information
in the (optional) \s-1STATUS\s0 struct.
If \f(CW\*(C`pid\*(C'\fR is \-1, return any process that has exited or return \-1 if
no more child processes exist;
otherwise return \f(CW\*(C`pid\*(C'\fR or \-1 on error.
If \f(CW\*(C`nohang\*(C'\fR is non-zero, returns \-1 if the process does not exist or other
error, returns 0 if the process exists and has not exited, and
returns \f(CW\*(C`pid\*(C'\fR and updates \f(CW\*(C`status\*(C'\fR if the process has exited.
.IP "int wait(\s-1STATUS\s0 &status)" 4
.IX Item "int wait(STATUS &status)"
Same as \f(CW\*(C`waitpid(\-1, &status, 0)\*(C'\fR.
.IP "void warn(string fmt, ...args)" 4
.IX Item "void warn(string fmt, ...args)"
Output a printf-like message to stderr.
If fmt does not end with a newline, append
\&\*(L" in <filename> at line <linenum>.\en\*(R"
.IP "int write(\s-1FILE\s0 f, string buffer, int numBytes)" 4
.IX Item "int write(FILE f, string buffer, int numBytes)"
Write at most numBytes to the given \s-1FILE\s0 handle from the buffer.
Return the number of bytes written, or \-1 on error.
.SH "Example code"
.IX Header "Example code"
.SS "shapes.l"
.IX Subsection "shapes.l"
This is something we hand to our customers to see what \*(L"shape\*(R"
their source trees have.
.PP
.Vb 10
\&    #!/usr/bin/bk tclsh
\&    /*
\&     * Determine the files/size of each directory under a bk repository.
\&     * Optionally transform the directory names to obscure their structure.
\&     *
\&     * The idea is that you can run this script like this:
\&     *
\&     *   bk little shapes.l <path_to_root_of_repo>
\&     *
\&     * and get a list of directories with their sizes and number of files in
\&     * each of them. Save the output, then run it again with \-o:
\&     *
\&     *   bk little shapes.l \-o <path_to_root_of_repo>
\&     *
\&     * and send the output to BitMover.
\&     *
\&     * The names of all the directories will be rot13\*(Aqd and sorted (since
\&     * sort is a destructive transform, it makes it harder to reverse the
\&     * rot13). This is a weak form of obfuscation, but it lets BitMover
\&     * work with the directory structure without inadvertently learning
\&     * about the client\*(Aqs projects.
\&     *
\&     * The line numbers at the beginning is so that we can talk about a certain
\&     * directory by number without BitMover knowing the name of the directory.
\&     *
\&     *  ob@dirac.bitmover.com|src/contrib/shapes.l|20100723224240|23777
\&     *
\&     */
\&
\&    string      obscure(string s);      // pathname to no\-IP\-leak pathname
\&    string      pp(float n);            // pretty print a number, like df \-h
\&    string      rot13(string str);      // if you don\*(Aqt know, you don\*(Aqt know
\&
\&    int
\&    main(int ac, string[] av)
\&    {
\&            int         size, files, maxlen, n;
\&            int         do_obscure = 0;
\&            string      fn, root, dir, d, ob;
\&            FILE        f;
\&            struct      stat sb;
\&            struct      dirstats {
\&                int     files;
\&                int     size;
\&                int     total_files;
\&                int     total_size;
\&            } dirs{string};
\&
\&            dir = ".";
\&            if (ac == 3) {
\&                    if (av[1] == "\-o") {
\&                            do_obscure = 1;
\&                    } else {
\&                            fprintf(stderr, "usage: %s [\-o] [<dir>]\en", av[0]);
\&                            exit(1);
\&                    }
\&                    dir = av[2];
\&            } else if (ac == 2) {
\&                    if (av[1] == "\-o") {
\&                            do_obscure = 1;
\&                            dir = ".";
\&                    } else {
\&                            dir = av[1];
\&                    }
\&            } else if (ac > 3) {
\&                    fprintf(stderr, "usage: %s [\-o] [<dir>]\en", av[0]);
\&                    exit(1);
\&            }
\&            if (chdir(dir)) {
\&                    fprintf(stderr, "Could not chdir to %s\en", dir);
\&                    exit(1);
\&            }
\&            root = \`bk root\`;
\&            if (root == "") {
\&                    fprintf(stderr, "Must be run in a BitKeeper repository\en");
\&                    exit(1);
\&            }
\&            if (chdir(root)) {
\&                    fprintf(stderr, "Could not chdir to %s\en", root);
\&                    exit(1);
\&            }
\&
\&            size = 0;
\&            files = 0;
\&            f = popen("bk sfiles", "r");
\&            while (defined(fn = <f>)) {
\&                    dir = dirname(fn);
\&                    if (dir == "SCCS") {
\&                            dir = ".";
\&                    } else {
\&                             // remove SCCS and obscure
\&                            dir = dirname(dir);
\&                    }
\&                    unless (defined(dirs{dir})) dirs{dir} = {0, 0, 0, 0};
\&                    if (maxlen < length(dir)) maxlen = length(dir);
\&                    dirs{dir}.files++;
\&                    files++;
\&                    if (lstat(fn, &sb)) {
\&                            fprintf(stderr, "Could not stat %s\en", fn);
\&                            continue;
\&                    }
\&                    dirs{dir}.size += sb.st_size;
\&                    size += sb.st_size;
\&                    // add our size/file count to each parent dir
\&                    for (d = dirname(dir); d != "."; d = dirname(d)) {
\&                            unless (defined(dirs{d})) dirs{d} = {0,0,0,0};
\&                            dirs{d}.total_size += sb.st_size;
\&                            dirs{d}.total_files++;
\&                    }
\&                    dirs{"."}.total_size += sb.st_size;
\&                    dirs{"."}.total_files++;
\&            }
\&            close(f);
\&            // now print it
\&            printf("  N   | %\-*s | FILES | SIZE    | T_FILES | T_SIZE \en",
\&                maxlen, "DIRS");
\&            n = 1;
\&            foreach (dir in sort(keys(dirs))) {
\&                    ob = dir;
\&                    if (do_obscure) {
\&                            ob = obscure(dir);
\&                    }
\&                    if (dirs{dir}.total_files > 0) {
\&                            printf("%5d | %\-*s | %5d | %7s | %7s | %7s\en",
\&                                n, maxlen,
\&                                ob, dirs{dir}.files, pp(dirs{dir}.size),
\&                                dirs{dir}.total_files, pp(dirs{dir}.total_size));
\&                    } else {
\&                            printf("%5d | %\-*s | %5d | %7s | %7s | %7s\en",
\&                                n, maxlen,
\&                                ob, dirs{dir}.files, pp(dirs{dir}.size),
\&                                "","");
\&                    }
\&                    n++;
\&            }
\&            printf("TOTAL: %u files, %s\en",
\&                dirs{"."}.total_files, pp(dirs{"."}.total_size));
\&            return (0);
\&    }
\&
\&    /* Pretty print a number */
\&    string
\&    pp(float n)
\&    {
\&            int         i;
\&            float       num = (float)n;
\&            string      sizes[] = {"b", "K", "M", "G", "T"};
\&
\&            for (i = 0; i < 5; i++) {
\&                    if (num < 1024.0) return (sprintf("%3.2f%s", num, sizes[i]));
\&                    num /= 1024.0;
\&            }
\&    }
\&
\&    /* Table for rot13 function below */
\&    string rot13_table{string} = {
\&            "A" => "N", "B" => "O", "C" => "P", "D" => "Q", "E" => "R", "F" => "S",
\&            "G" => "T", "H" => "U", "I" => "V", "J" => "W", "K" => "X", "L" => "Y",
\&            "M" => "Z", "N" => "A", "O" => "B", "P" => "C", "Q" => "D", "R" => "E",
\&            "S" => "F", "T" => "G", "U" => "H", "V" => "I", "W" => "J", "X" => "K",
\&            "Y" => "L", "Z" => "M",     "a" => "n", "b" => "o", "c" => "p", "d" => "q",
\&            "e" => "r", "f" => "s", "g" => "t", "h" => "u", "i" => "v", "j" => "w",
\&            "k" => "x", "l" => "y", "m" => "z", "n" => "a", "o" => "b", "p" => "c",
\&            "q" => "d", "r" => "e", "s" => "f", "t" => "g", "u" => "h", "v" => "i",
\&            "w" => "j", "x" => "k", "y" => "l", "z" => "m",
\&    };
\&
\&    /* rot13 a string */
\&    string
\&    rot13(string str)
\&    {
\&            int         i;
\&            string      ret = "";
\&
\&            for (i = 0; i < length(str); i++) {
\&                    ret .= rot13_table{str[i]};
\&            }
\&            return (ret);
\&    }
\&
\&    /*
\&     * Print an obscured version of the string
\&     * rot13 + sort
\&     */
\&    string
\&    obscure(string s)
\&    {
\&            string      p;
\&            string[]    ret;
\&            string[]    sp = split(s, "/");
\&
\&            foreach (p in sp) {
\&                    push(&ret, rot13(join("", lsort(split(p, "")))));
\&            }
\&            return (join("/", ret));
\&    }
.Ve
.SS "photos.l"
.IX Subsection "photos.l"
.Vb 10
\&    #!/usr/bin/bk tclsh
\&    /*
\&     * A rewrite of Eric Pop\*(Aqs fine igal program in Little.  I talked to Eric and he
\&     * really doesn\*(Aqt want anything to do with supporting igal or copycats so
\&     * while credit here is cool, don\*(Aqt stick his name on the web pages.
\&     * I completely understand that, people still ask me about webroff and
\&     * lmbench.
\&     *
\&     * First version by Larry McVoy Sun Dec 19 2010.  Public Domain.
\&     *
\&     * usage photos [options] [dir]
\&     *
\&     * TODO
\&     * \- slideshow mode
\&     * \- move the next/prev/index to the sides along w/ EXIF info
\&     */
\&    int bigy = 750;             // \-\-bigy=%d for medium images
\&    int dates = 0;              // \-\-date\-split
\&    int exif = 0;               // \-\-exif under titles
\&    int exif_hover = 0;         // \-\-exif\-hover, exif data in thumbnail hover
\&    int exif_thumbs = 0;        // \-\-exif\-thumbnails, use the camera thumbnail
\&    int force = 0;              // \-f force regen of everything
\&    int names = 0;              // put names below the image
\&    int nav = 0;                // month/year nav
\&    int parallel = 1;           // \-j%d for multiple processes
\&    int sharpen = 0;            // \-\-sharpen to turn it on
\&    int thumbnails = 0;         // force regen of those
\&    int quiet = 1;              // turn off verbose
\&    string      title = "McVoy photos"; // \-\-title=whatever
\&    int ysize = 120;            // \-ysize=%d for thumbnails
\&    int rotate[];               // amount to rotate, \-+90
\&    string      indexf = "~/.photos/index.html";
\&    string      slidef = "~/.photos/slide.html";
\&
\&    int
\&    main(int ac, string av[])
\&    {
\&            string      c;
\&            string      lopts[] = {
\&                    "bigy:",
\&                    "date\-split",
\&                    "exif",
\&                    "exif\-thumbnails",
\&                    "exif\-hover",
\&                    "force",
\&                    "index:",
\&                    "names",
\&                    "nav",
\&                    "parallel:",
\&                    "quiet",
\&                    "regen",
\&                    "sharpen",
\&                    "slide:",
\&                    "thumbnails",
\&                    "title:",
\&                    "ysize:",
\&            };
\&
\&            if (0) ac = 0;      // lint
\&            parallel = cpus();
\&            dotfiles();
\&
\&            while (c = getopt(av, "fj:", lopts)) {
\&                    switch (c) {
\&                        case "bigy": bigy = (int)optarg; break;
\&                        case "date\-split": dates = 1; break;
\&                        case "exif": exif = 1; break;
\&                        case "exif\-hover": exif_hover = 1; break;
\&                        case "exif\-thumbnails": exif_thumbs = 1; break;
\&                        case "f":
\&                        case "force":
\&                        case "regen":
\&                            force = 1; break;
\&                        case "index": indexf = optarg; break;
\&                        case "j":
\&                        case "parallel": parallel = (int)optarg; break;
\&                        case "quiet": quiet = 1; break;
\&                        case "names": names = 1; break;
\&                        case "nav": nav = 1; break;
\&                        case "sharpen": sharpen = 1; break;
\&                        case "slide": slidef = optarg; break;
\&                        case "title": title = optarg; break;
\&                        case "thumbnails": thumbnails = 1; break;
\&                        case "ysize": ysize = (int)optarg; break;
\&                        default: 
\&                        printf("Usage: photos.l");
\&                        foreach(c in lopts) {
\&                            if (c =~ /(.*):/) {
\&                                printf(" \-\-%s=<val>", $1);
\&                            } else {
\&                                printf(" \-\-%s", c);
\&                            }
\&                        }
\&                        printf("\en");
\&                        return(0);
\&                    }
\&            }
\&            unless (av[optind]) {
\&                dir(".");
\&            } else {
\&                while (av[optind]) dir(av[optind++]);
\&            }
\&            return (0);
\&    }
\&
\&    void
\&    dir(string d)
\&    {
\&            string      jpegs[];
\&            string      tmp[];
\&            string      buf;
\&            int i;
\&
\&            if (chdir(d)) die("can\*(Aqt chdir to %s", d);
\&            tmp = getdir(".", "*.jpeg");
\&            unless (tmp[0]) tmp = getdir(".", "*.jpg");
\&            unless (tmp[0]) tmp = getdir(".", "*.png");
\&            unless (tmp[0]) tmp = getdir(".", "*.PNG");
\&            unless (tmp[0]) die("No jpegs found in %s", d);
\&            // XXX \- should getdir do this?
\&            for (i = 0; defined(tmp[i]); i++) tmp[i] =~ s|^\e./||;
\&
\&            /* so we start at one not zero */
\&            jpegs[0] = \*(Aq.\*(Aq;
\&            rotate[0] = 0;
\&            // XXX \- I want push(&jpegs, list)
\&            foreach (buf in tmp) {
\&                    push(&jpegs, buf);
\&                    push(&rotate, rotation(buf));
\&            }
\&
\&            slides(jpegs);
\&            thumbs(jpegs);
\&            html(jpegs);
\&    }
\&
\&    /*
\&     * Create .thumb\-$file if
\&     * \- it does not exist
\&     * \- .ysize is different than ysize
\&     * \- $file is newer than thumbnail
\&     */
\&    void
\&    thumbs(string jpegs[])
\&    {
\&            string      cmd[];
\&            string      jpeg, file, slide;
\&            int i;
\&            int all = 0;
\&            int my_parallel = parallel, bg = 0;
\&            int pid, reaped;
\&            int pids{int};
\&
\&            unless (exists(".ysize")) {
\&    save:               Fprintf(".ysize", "%d\en", ysize);
\&            }
\&            if ((int)\`cat .ysize\` != ysize) {
\&                    all = 1;
\&                    goto save;
\&            }
\&            if (force || thumbnails) all = 1;
\&            if (exif_thumbs) my_parallel = 1;
\&            for (i = 1; defined(jpeg = jpegs[i]); i++) {
\&                    file = sprintf(".thumb\-%s", jpeg);
\&                    slide = sprintf(".slide\-%s", jpeg);
\&                    if (!all && exists(file) && (mtime(file) > mtime(jpeg))) {
\&                            continue;
\&                    }
\&
\&                    if (exif_thumbs && do_exif(undef, jpeg)) {
\&                            unlink(file);
\&                            cmd = {
\&                                "exif",
\&                                "\-e",
\&                                "\-o", file,
\&                                jpeg
\&                            };
\&                    } else {
\&                            cmd = {
\&                                "convert",
\&                                "\-thumbnail",
\&                                "x${ysize}",
\&                                "\-quality", "85",
\&                            };
\&                            if (sharpen) {
\&                                    push(&cmd, "\-unsharp");
\&                                    //push(&cmd, "0x.5");
\&                                    push(&cmd, "2x0.5+0.7+0");
\&                            }
\&                            push(&cmd, exists(slide) ? slide : jpeg);
\&                            push(&cmd, file);
\&                    }
\&                    while (bg >= parallel) {
\&                            reaped = 0;
\&                            foreach (pid in keys(pids)) {
\&                                    if (waitpid(pid, undef, 1) > 0) {
\&                                            reaped++;
\&                                            bg\-\-;
\&                                            undef(pids{pid});
\&                                            break;
\&                                    }
\&                            }
\&                            if (reaped) break;
\&                            sleep(0.100);
\&                    }
\&                    unless (quiet) {
\&                            printf("Creating %s from %s\en",
\&                                file, exists(slide) ? slide : jpeg);
\&                    }
\&                    pid = spawn(cmd);
\&                    unless (defined(stdio_status.path)) {
\&                            die("%s: command not found.\en", cmd[0]);
\&                    }
\&                    bg++;
\&                    pids{pid} = 1;
\&            }
\&            foreach (pid in keys(pids)) waitpid(pid, undef, 0);
\&    }
\&
\&    /*
\&     * Create .slide\-$file if
\&     * \- it does not exist
\&     * \- .bigy is different than bigy
\&     * \- $file is newer than slide
\&     * \- $file is bigger than bigy
\&     */
\&    void
\&    slides(string jpegs[])
\&    {
\&            string      cmd[];
\&            string      jpeg, file;
\&            int all = 0;
\&            int i;
\&            int bg = 0;
\&            int pid, reaped;
\&            int pids{int};
\&
\&            unless (exists(".bigy")) {
\&    save:               Fprintf(".bigy", "%d\en", bigy);
\&            }
\&            if ((int)\`cat .bigy\` != bigy) {
\&                    all = 1;
\&                    goto save;
\&            }
\&            if (force) all = 1;
\&            for (i = 1; defined(jpeg = jpegs[i]); i++) {
\&                    file = sprintf(".slide\-%s", jpeg);
\&                    if (!all && exists(file) && (mtime(file) > mtime(jpeg))) {
\&                            continue;
\&                    }
\&                    if (small(jpeg)) {
\&                            unlink(file);
\&                            if (link(jpeg, file)) warn("link ${jpeg} ${file}");
\&                            continue;
\&                    }
\&                    cmd = {
\&                        "convert",
\&                        "+profile", "*",
\&                        "\-scale", "x" . "${bigy}",
\&                        "\-quality", "85",
\&                    };
\&                    if (rotate[i]) {
\&                            push(&cmd, "\-rotate");
\&                            push(&cmd, sprintf("%d", rotate[i]));
\&                    }
\&                    if (sharpen) {
\&                            push(&cmd, "\-unsharp");
\&                            //push(&cmd, "0x.5");
\&                            push(&cmd, "2x0.5+0.7+0");
\&                    }
\&                    push(&cmd, jpeg);
\&                    push(&cmd, file);
\&                    while (bg >= parallel) {
\&                            reaped = 0;
\&                            foreach (pid in keys(pids)) {
\&                                    if (waitpid(pid, undef, 1) > 0) {
\&                                            reaped++;
\&                                            bg\-\-;
\&                                            undef(pids{pid});
\&                                            break;
\&                                    }
\&                            }
\&                            if (reaped) break;
\&                            sleep(0.150);
\&                    }
\&                    unless (quiet) {
\&                            printf("Creating %s from %s\en", file, jpeg);
\&                    }
\&                    printf("%s\en", join(" ", cmd));
\&                    pid = spawn(cmd);
\&                    unless (defined(stdio_status.path)) {
\&                            die("%s: command not found.\en", cmd[0]);
\&                    }
\&                    bg++;
\&                    pids{pid} = 1;
\&            }
\&            foreach (pid in keys(pids)) waitpid(pid, undef, 0);
\&    }
\&
\&    int
\&    small(string file)
\&    {
\&            string      buf;
\&
\&            // Hack to avoid exif calls on small files
\&            if (size(file) < 100000) return (1);
\&            if (size(file) > 200000) return (0);
\&            unless (buf = \`identify \*(Aq${file}\*(Aq\`) return (0);
\&            if (buf =~ /JPEG (\ed+)x(\ed+)/) return ((int)$2 <= bigy);
\&            return (0);
\&    }
\&
\&    string num2mon{int} = {
\&            1 => "January",
\&            2 => "February",
\&            3 => "March",
\&            4 => "April",
\&            5 => "May",
\&            6 => "June",
\&            7 => "July",
\&            8 => "August",
\&            9 => "September",
\&            10 => "October",
\&            11 => "November",
\&            12 => "December",
\&    };
\&
\&    typedef     struct {
\&            int day;    // day 1..31
\&            int mon;    // month 1..12
\&            int year;   // year as YYYY
\&            string      sdate;  // YYYY\-MM\-DD
\&    } date;
\&
\&    /*
\&     * Return the date either from the filename if it is one of date ones,
\&     * or from the exif data,
\&     * or fall back to mtime.
\&     */
\&    date
\&    f2date(string file)
\&    {
\&            date        d;
\&            string      buf;
\&            FILE        f;
\&            int t;
\&
\&            if (file =~ /^(\ed\ed\ed\ed)\-(\ed\ed)\-(\ed\ed)/) {
\&    match:              
\&                    buf = (string)$3; buf =~ s/^0//; d.day = (int)buf;
\&                    buf = (string)$2; buf =~ s/^0//; d.mon = (int)buf;
\&                    d.year = (int)$1;
\&                    d.sdate = sprintf("%d\-%02d\-%02d", d.year, d.mon, d.day);
\&                    return (d);
\&            }
\&
\&            if (f = popen("exif \-t DateTime \*(Aq${file}\*(Aq 2>/dev/null", "r")) {
\&                    while (buf = <f>) {
\&                            // Value: 2006:02:04 22:59:24
\&                            if (buf =~ /Value: (\ed\ed\ed\ed):(\ed\ed):(\ed\ed)/) {
\&                                    pclose(f);
\&                                    goto match;
\&                            }
\&                    }
\&                    pclose(f);
\&                    // fall through to mtime
\&            }
\&
\&            if (t = mtime(file)) {
\&                    buf = Clock_format(t, format: "%Y:%m:%d");
\&                    buf =~ /(\ed\ed\ed\ed):(\ed\ed):(\ed\ed)/;
\&                    goto match;
\&            }
\&
\&            return (undef);
\&    }
\&
\&    /*
\&     * Create the html slide files and index.html
\&     * XXX \- could stub this out if mtime(html) > mtime(.slide) etc.
\&     */
\&    void
\&    html(string jpegs[])
\&    {
\&            string      template, file, stitle, ntitle, ptitle, buf;
\&            string      cap = \*(Aq\*(Aq;
\&            string      date_nav = \*(Aq\*(Aq;
\&            string      dir, jpeg, escaped, thumbs = \*(Aq\*(Aq;
\&            int i, next, prev;
\&            int first = 1;
\&            FILE        f;
\&            string      map[];
\&            string      exdata;
\&            date        d, d2;
\&
\&            unless (f = fopen(slidef, "rv")) die("slide.html");
\&            read(f, &template, \-1);
\&            fclose(f);
\&
\&            for (i = 1; defined(jpeg = jpegs[i]); i++) {
\&                    file = sprintf("%d.html", i);
\&                    if (i > 1) {
\&                            prev = i \- 1;
\&                    } else {
\&                            prev = length(jpegs) \- 1;
\&                    }
\&                    if (jpegs[i+1]) {
\&                            next = i + 1;
\&                    } else {
\&                            next = 1;
\&                    }
\&                    undef(map);
\&                    stitle = jpeg;
\&                    stitle =~ s/\e.jp.*//;
\&                    ntitle = jpegs[next];
\&                    ntitle =~ s/\e.jp.*//;
\&                    ptitle = jpegs[prev];
\&                    ptitle =~ s/\e.jp.*//;
\&                    escaped = jpeg;
\&                    escaped =~ s/:/%3A/g;
\&                    dir = \`pwd\`;
\&                    dir =~ s|.*/||;
\&                    map = {
\&                            "%FOLDER%",
\&                            dir,
\&                            "%TITLE%",
\&                            stitle,
\&                            "%NEXT_HTML%",
\&                            sprintf("%d.html", next),
\&                            "%NEXT_TITLE%",
\&                            ntitle,
\&                            "%PREV_HTML%",
\&                            sprintf("%d.html", prev),
\&                            "%PREV_TITLE%",
\&                            ptitle,
\&                            "%NEXT_SLIDE%",
\&                            sprintf(".slide\-%s", jpegs[next]),
\&                            "%ORIG%",
\&                            escaped,
\&                            "%SLIDE%",
\&                            sprintf(".slide\-%s", escaped),
\&                    };
\&                    push(&map, "%CAPTION%");
\&                    if (names || exif) cap = \*(Aq<P class="center">\*(Aq;
\&                    if (names) {
\&                            cap .= stitle .
\&                                \*(Aq&nbsp;&nbsp;&nbsp;\*(Aq .
\&                                sprintf("(%d/%d)\en", i, length(jpegs) \- 1);
\&                    }
\&                    undef(exdata);
\&                    if (exif) {
\&                            do_exif(&exdata, jpeg);
\&                            if (names) cap .= "<br>";
\&                            cap .= exdata;
\&                    }
\&                    if (names || exif) cap .= "</P>\en";
\&                    push(&map, cap);
\&
\&                    push(&map, "%NAV%");
\&                    date_nav = \*(Aq\*(Aq;
\&                    do_nav(&date_nav, jpeg, prev, next, 1);
\&                    push(&map, date_nav);
\&
\&                    buf = String_map(map, template);
\&                    Fprintf(file, "%s\en", buf);
\&
\&                    if (dates &&
\&                        defined(d2 = f2date(jpeg)) &&
\&                        (first || (d.sdate != d2.sdate))) {
\&                            d = d2;
\&                            unless (first) thumbs .= "</DIV>\en";
\&                            buf = num2mon{d.mon};
\&                            thumbs .= "<p><a name=\e"${buf}_${d.day}\e">";
\&                            cap = "${buf} ${d.day} ${d.year}";
\&                            thumbs .= cap . "</a>";
\&                            cap = ".cap\-${buf}\-${d.day}\-${d.year}";
\&                            // .cap\-January\-09\-2011, if exists, is appended
\&                            if (exists(cap) && (cap = \`cat ${cap}\`)) {
\&                                    thumbs .= \*(Aq: \*(Aq . cap;
\&                            }
\&                            thumbs .= "<br>\en<DIV class=\e"center\e">\en";
\&                    }
\&
\&                    if (exif && exif_hover) stitle .= " " . exdata;
\&                    thumbs .= sprintf(
\&                        \*(Aq<a href="%s">\*(Aq .
\&                        \*(Aq<img src=".thumb\-%s" alt="%s" title="%s" border="0"/>\*(Aq . 
\&                        \*(Aq</a>\*(Aq . "\en",
\&                        file, escaped, stitle, stitle);
\&                    first = 0;
\&            }
\&            
\&            /* do index.html */
\&            unless (f = fopen(indexf, "rv")) die("index.html");
\&            read(f, &template, \-1);
\&            fclose(f);
\&            undef(map);
\&            push(&map, "%TITLE%");
\&            push(&map, title);
\&            push(&map, "%THUMBS%");
\&            thumbs .= "</DIV>\en";
\&            push(&map, thumbs);
\&            date_nav = \*(Aq\*(Aq;
\&            push(&map, "%NAV%");
\&            do_nav(&date_nav, jpegs[1], undef, undef, 0);
\&            push(&map, date_nav);
\&            buf = String_map(map, template);
\&            if (exists(".index\-include")) {
\&                    buf .= \`cat .index\-include\`;
\&            }
\&            Fprintf("index.html", "%s", buf);
\&            unless (f = fopen("~/.photos/photos.css", "rv")) die("photos.css");
\&            read(f, &buf, \-1);
\&            fclose(f);
\&            Fprintf("photos.css", "%s", buf);
\&    }
\&
\&    /*
\&     * XXX \- what this needs is a hash and then at the end I push the info
\&     * I want in the order I want.
\&     */
\&    int
\&    do_exif(string &cap, string jpeg)
\&    {
\&            FILE        f = popen("exiftags \-a \*(Aq${jpeg}\*(Aq", "rv");
\&            string      save, buf, maker = \*(Aq\*(Aq;
\&            string      v[];
\&            string      iso = undef;
\&            int thumb = 0;
\&            int i;
\&            string      tags{string};
\&
\&            while (buf = <f>) {
\&                    switch (trim(buf)) {
\&                        case /^Equipment Make: (.*)/:
\&                            maker = $1;
\&                            if (maker == "OLYMPUS IMAGING CORP.") {
\&                                    maker = "Olympus";
\&                            }
\&                            if (maker == "NIKON CORPORATION") {
\&                                    maker = "Nikon";
\&                            }
\&                            break;
\&                        case /^Camera Model: (.*)/:
\&                            save = $1;
\&                            if (save =~ /${maker}/i) {
\&                                    tags{"camera"} = save;
\&                            } else {
\&                                    tags{"camera"} = "${maker} ${save}";
\&                            }
\&                            if (save == "TG\-1") tags{"lens"} = "25\-100mm f2.0";
\&                            if (save =~ /Canon PowerShot S95/) {
\&                                    tags{"lens"} = "28\-105 mm";
\&                            }
\&                            if (save =~ /Canon PowerShot S100/) {
\&                                    tags{"lens"} = "24\-120mm";
\&                            }
\&                            break;
\&                        case /Lens Name: (.*)/:
\&                            if ($1 =~ /EF\ed/) $1 =~ s/EF/EF /;
\&                            if ($1 =~ /EF\-S\ed/) $1 =~ s/EF\-S/EF\-S /;
\&                            if ($1 =~ / USM/) $1 =~ s/ USM//;
\&                            if ($1 == "30mm") $1 = "Sigma 30mm f/1.4";
\&                            if ($1 == "90mm") $1 = "Tamron 90mm macro";
\&                            if ($1 == "18\-200mm") $1 = "Tamron 18\-200mm";
\&                            if ($1 == "18\-250mm") $1 = "Tamron 18\-250mm";
\&                            if ($1 == "18\-270mm") $1 = "Tamron 18\-270mm";
\&                            if ($1 == "170\-500mm") $1 = "Sigma 170\-500mm";
\&                            $1 =~ s|f/|f|;
\&                            tags{"lens"} = $1;
\&                            break;
\&                        case /Lens Size: 10.00 \- 22.00 mm/:
\&                            tags{"lens"} = "EF\-S 10\-22mm f/3.5\-4.5";
\&                            break;
\&                        case /Exposure Bias: (.*)/:
\&                            if ($1 != "0 EV") {
\&                                    unless ($1 =~ /^\-/) $1 = "+" . $1;
\&                                    tags{"bias"} = $1;
\&                            }
\&                            break;
\&                        case /^Exposure Time: (.*)/:
\&                            save = $1;
\&                            $1 =~ /(\ed+)\e/(\ed+) sec/;
\&                            if ((int)$1 > 1) {
\&                                    i = (int)$2/(int)$1;
\&                                    save = "1/${i}";
\&                            }
\&                            tags{"time"} = save;
\&                            break;
\&                        case /Lens Aperture: (.*)/:
\&                        case /F\-Number: (.*)/:
\&                            $1 =~ s|/||;
\&                            tags{"fstop"} = $1;
\&                            break;
\&                        case /ISO Speed Rating: (.*)/:
\&                            iso = undef;
\&                            if ($1 == "Auto") {
\&                                    iso = "ISO ${$1}";
\&                            } else if ($1 == "Unknown") {
\&                                    ;
\&                            } else unless ((int)$1 == 0) {
\&                                    iso = "ISO ${$1}";
\&                            }
\&                            if (defined(iso)) tags{"iso"} = iso;
\&                            break;
\&                        case /Focal Length .35mm Equiv.: (.*)/:
\&                        case /Focal Length: (.*)/:
\&                            save = $1;
\&                            if (tags{"camera"} =~ /Canon PowerShot S95/) {
\&                                    save =~ s/ mm//;
\&                                    save = (string)(int)((float)save * 4.7);
\&                                    save .= " mm";
\&                            }
\&                            if (tags{"camera"} =~ /Canon PowerShot S100/) {
\&                                    save =~ s/ mm//;
\&                                    save = (string)(int)((float)save * 4.61538);
\&                                    save .= " mm";
\&                            }
\&                            unless (defined(tags{"focal"})) {
\&                                    tags{"focal"} = save;
\&                            }
\&                            break;
\&                        case /Metering Mode: (.*)/:
\&                            unless (defined(tags{"metering"})) {
\&                                    tags{"metering"} = "${$1} metering";
\&                            }
\&                            break;
\&                        case /White Balance: (.*)/:
\&                            unless ($1 =~ /white balance/) $1 .= " white balance";
\&                            $1 =~ s/white balance/WB/;
\&                            unless (defined(tags{"balance"})) {
\&                                    tags{"balance"} = $1;
\&                            }
\&                            break;
\&                        case /Compression Scheme: JPEG Compression .Thumbnail./:
\&                            thumb = 1;
\&                            break;
\&                    }
\&            }
\&            fclose(f);
\&            cap = "";
\&            if (defined(tags{"camera"})) push(&v, tags{"camera"});
\&            if (defined(tags{"lens"})) {
\&                    if (defined(tags{"focal"}) && 
\&                        (tags{"lens"} =~ /[0\-9]\-[0\-9]/)) {
\&                            tags{"lens"} .= " @ " . tags{"focal"};
\&                    }
\&                    push(&v, tags{"lens"});
\&            }
\&            if (defined(tags{"fstop"})) push(&v, tags{"fstop"});
\&            if (defined(tags{"time"})) push(&v, tags{"time"});
\&            if (defined(tags{"bias"})) push(&v, tags{"bias"});
\&            if (defined(tags{"iso"})) push(&v, tags{"iso"});
\&            if (defined(tags{"metering"})) push(&v, tags{"metering"});
\&            if (defined(tags{"balance"})) push(&v, tags{"balance"});
\&            if (defined(v)) cap = join(", ", v);
\&            return (thumb);
\&    }
\&
\&    int
\&    rotation(string file)
\&    {
\&            string      r = \`exif \-m \-t Orientation \*(Aq${file}\*(Aq\`;
\&
\&            switch (r) {
\&                case /right.*top/i:
\&                    return (90);
\&                case /left.*bottom/i:
\&                    return (\-90);
\&                default:
\&                    return (0);
\&            }
\&    }
\&
\&    /*
\&     * This is called for both index nav and slide nav.
\&     * For index nav, unless nav is set, do nothing.
\&     * For slide nav, always do at least 
\&     * prev | index | next 
\&     * and optionally
\&     * prev | next | prev month | index | next month | prev year | next year
\&     */
\&    void
\&    do_nav(string &date_nav, string jpeg, int prev, int next, int slide)
\&    {
\&            int i, mon, did_it;
\&            string      buf, month;
\&            date        d;
\&
\&            date_nav = \*(Aq\*(Aq;
\&            if (!nav && !slide) return;
\&
\&            unless (defined(d = f2date(jpeg))) return;
\&            month = num2mon{d.mon}[0..2];
\&
\&            if (slide) {
\&                    /* <<< prev | January | next >>> */
\&                    date_nav .= \*(Aq<a href="\*(Aq . sprintf("%d.html", prev) .
\&                        \*(Aq">&lt;&lt; prev pic</a>&nbsp;&nbsp;\*(Aq;
\&                    date_nav .= "\en";
\&                    unless (nav) {
\&                            date_nav .= \*(Aq<a href="index.html">Index</a>&nbsp;&nbsp;\*(Aq;
\&                            date_nav .= "\en";
\&                    }
\&                    date_nav .= \*(Aq<a href="\*(Aq . sprintf("%d.html", next) .
\&                        \*(Aq">next pic &gt;&gt;</a>\*(Aq;
\&                    date_nav .= "\en";
\&
\&                    unless (nav) return;
\&            }
\&
\&            /* <<< prev | next >>> |  <<< January >>> | <<< 2003 >>> */
\&            date_nav .= "\en";
\&            date_nav .= \*(Aq&nbsp;&nbsp;&nbsp;&nbsp;\*(Aq;
\&            date_nav .= "\en";
\&
\&            /* do the <<< for the prev month */
\&            for (i = 0; i < 12; i++) {
\&                    mon = d.mon \- i;
\&                    if (mon == 1) {
\&                            buf = sprintf("../../%d/%02d/index.html", d.year\-1, 12);
\&                    } else {
\&                            buf = sprintf("../../%d/%02d/index.html", d.year,mon\-1);
\&                    }
\&                    if (exists(buf)) break;
\&            }
\&            if (exists(buf)) date_nav .= \*(Aq<a href="\*(Aq . buf . \*(Aq">&lt;&lt;&lt;</a>\*(Aq;
\&            date_nav .= "\en";
\&
\&            /* do the link to index.html for this month */
\&            if (slide) {
\&                    date_nav .= \*(Aq&nbsp;&nbsp;<a href="index.html">\*(Aq . 
\&                        month . " index" . \*(Aq</a>&nbsp;&nbsp;\*(Aq;
\&            } else {
\&                    date_nav .= "&nbsp;&nbsp;${month}&nbsp;&nbsp;";
\&            }
\&            date_nav .= "\en";
\&
\&            /* do the >>> for next month */
\&            for (i = 0; i < 12; i++) {
\&                    mon = d.mon + i;
\&                    if (mon == 12) {
\&                            buf = sprintf("../../%d/%02d/index.html", d.year+1, 1);
\&                    } else {
\&                            buf = sprintf("../../%d/%02d/index.html", d.year,mon+1);
\&                    }
\&                    if (exists(buf)) break;
\&            }
\&            if (exists(buf)) {
\&                    date_nav .= \*(Aq<a href="\*(Aq . buf . \*(Aq">&gt;&gt;&gt;</a>\*(Aq;
\&            }
\&
\&            date_nav .= "\en";
\&            date_nav .= \*(Aq&nbsp;&nbsp;&nbsp;&nbsp;\*(Aq;
\&            date_nav .= "\en";
\&
\&            did_it = 0;
\&            buf = sprintf("../../%d/%02d/index.html", d.year \- 1, d.mon);
\&            unless (exists(buf)) for (i = 1; i < 12; i++) {
\&                    buf = sprintf("../../%d/%02d/index.html", d.year \- 1, d.mon+i);
\&                    if (exists(buf)) break;
\&                    buf = sprintf("../../%d/%02d/index.html", d.year \- 1, d.mon\-i);
\&                    if (exists(buf)) break;
\&            }
\&            if (exists(buf)) {
\&                    date_nav .= \*(Aq<a href="\*(Aq .
\&                        buf . \*(Aq">&lt;&lt;&lt;</a>&nbsp;\*(Aq .  "${d.year}";
\&                    date_nav .= "\en";
\&                    did_it++;
\&            }
\&            buf = sprintf("../../%d/%02d/index.html", d.year + 1, d.mon);
\&            unless (exists(buf)) for (i = 1; i < 12; i++) {
\&                    buf = sprintf("../../%d/%02d/index.html", d.year + 1, d.mon+i);
\&                    if (exists(buf)) break;
\&                    buf = sprintf("../../%d/%02d/index.html", d.year + 1, d.mon\-i);
\&                    if (exists(buf)) break;
\&            }
\&            if (exists(buf)) {
\&                    unless (did_it) date_nav .= "${d.year}";
\&                    date_nav .= \*(Aq&nbsp;<a href="\*(Aq . buf . \*(Aq">&gt;&gt;&gt;</a>\*(Aq;
\&                    date_nav .= "\en";
\&            }
\&    }
\&
\&    void
\&    dotfiles(void)
\&    {
\&            string      file, buf;
\&
\&            unless (isdir("~/.photos")) mkdir("~/.photos");
\&            file = "~/.photos/slide.html";
\&            unless (exists(file)) {
\&                    buf = <<\*(AqEND\*(Aq
\&    <!DOCTYPE HTML PUBLIC "\-//W3C//DTD HTML 4.01 Transitional//EN">
\&    <HTML>
\&      <HEAD>
\&        <META http\-equiv="Content\-Type" content="text/html; charset=ISO\-8859\-1">
\&        <TITLE>%TITLE%</TITLE>
\&        <LINK rel="stylesheet" type="text/css" href="photos.css">
\&        <LINK rel="contents" href="index.html">
\&        <LINK rel="next" href="%NEXT_HTML%" title="%NEXT_TITLE%">
\&        <LINK rel="previous" href="%PREV_HTML%" title="%PREV_TITLE%">
\&        <SCRIPT type="text/javascript" language="javascript" defer>
\&           <!\-\-
\&           if (document.images)    {
\&              Image1          = new Image();
\&              Image1.src      = "%NEXT_SLIDE%";
\&           }       //\-\->   
\&        </SCRIPT>
\&      </HEAD>
\&
\&      <BODY>
\&        <P class="center">
\&          %NAV%
\&        </P>
\&        <DIV class="center">
\&          <TABLE bgcolor="#ffffff" cellspacing=0 cellpadding=4>
\&            <TR>
\&              <TD class="slide">
\&                <A href="%ORIG%">
\&                <IMG src="%SLIDE%" alt="%TITLE%"
\&                title="Click here to see full size, then use your back button."
\&                border=0></a>
\&              </TD>
\&            </TR>
\&          </TABLE>
\&          <P>
\&          %CAPTION%
\&        </DIV>
\&      </BODY>
\&    </HTML>
\&    END;
\&                    Fprintf(file, "%s", buf);
\&            }
\&            file = "~/.photos/index.html";
\&            unless (exists(file)) {
\&                    buf = <<\*(AqEND\*(Aq
\&    <!DOCTYPE HTML PUBLIC "\-//W3C//DTD HTML 4.01 Transitional//EN">
\&
\&    <HTML>
\&      <HEAD>
\&        <META http\-equiv="Content\-Type" content="text/html; charset=ISO\-8859\-1">
\&        <TITLE>%TITLE%</TITLE>
\&        <LINK rel="stylesheet" type="text/css" href="photos.css">
\&      </HEAD>
\&
\&      <BODY>
\&        %TITLE%
\&        &nbsp;
\&        &nbsp;
\&        &nbsp;
\&        &nbsp;
\&        %NAV%
\&        <p>
\&        %THUMBS%
\&        <p align="center">
\&        %NAV%
\&        <P class="small">
\&        For each picture there are 3 sizes:
\&        (1) the index thumbnails you are looking at,
\&        (2) a mid sized picture that you get to by clicking the thumbnail,
\&        (3) the original that you get to by clicking the midsize.
\&        Legal crud: everything is copyrighted by whoever took the picture.
\&        In the unlikely event you want to use a picture, please ask just to make
\&        us feel good.
\&        </P>
\&      </BODY>
\&    </HTML>
\&    END;
\&                    Fprintf(file, "%s", buf);
\&            }
\&            file = "~/.photos/photos.css";
\&            unless (exists(file)) {
\&                    buf = <<\*(AqEND\*(Aq
\&    .center { 
\&      text\-align: center;
\&    }
\&
\&    .center table { 
\&      margin\-left: auto;
\&      margin\-right: auto;
\&      text\-align: center;
\&    }
\&
\&    body {
\&      font\-family: verdana, sans\-serif;
\&      background: #000000;
\&      color: #DDDDDD;
\&    }
\&
\&    a:link {
\&      color: #95DDFF;
\&      background: transparent;
\&    }
\&
\&    a:visited {
\&      color: #AAAAAA;
\&      background: transparent;
\&    }
\&
\&    a:hover {
\&      color: #BBDDFF;
\&      background: #555555;
\&    }
\&
\&    .small {
\&      font\-size: 50%;
\&    }
\&
\&    .large {
\&      font\-size: 200%;
\&    }
\&
\&    .tiled {
\&      background\-image: url(".tile.png");
\&      background\-repeat: repeat\-x;
\&      background\-color: #000000;
\&      padding: 0;
\&    }
\&
\&    .thumb {
\&      background\-color: #000000;
\&      text\-align: center;
\&      vertical\-align: middle;
\&    }
\&
\&    .slide {
\&      background\-color: #ffffff;
\&      text\-align: center;
\&      vertical\-align: middle;
\&    }
\&    END;
\&                    Fprintf(file, "%s", buf);
\&            }
\&    }
.Ve
.\" help://L
.\" help://l
